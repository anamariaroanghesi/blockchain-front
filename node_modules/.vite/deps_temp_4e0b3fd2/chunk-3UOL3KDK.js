"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
      "use strict";
      init_dist();
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
      init_dist();
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s2 = buffer[offset + i];
        i += d;
        e = s2 & (1 << -nBits) - 1;
        s2 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s2 ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s2 ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s2 * 128;
      };
    }
  });

  // node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/.pnpm/buffer@6.0.3_patch_hash=zkkuxompt5d553skpnegwi5wuy/node_modules/buffer/index.js"(exports) {
      "use strict";
      init_dist();
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer2;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      var { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new GlobalUint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new GlobalUint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (GlobalArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, GlobalUint8Array.prototype);
      Object.setPrototypeOf(Buffer2, GlobalUint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i = 0; i < length; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, GlobalUint8Array)) {
          const copy = new GlobalUint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new GlobalUint8Array(array);
        } else if (length === void 0) {
          buf = new GlobalUint8Array(array, byteOffset);
        } else {
          buf = new GlobalUint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, GlobalUint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, GlobalUint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length === void 0) {
          length = 0;
          for (i = 0; i < list.length; ++i) {
            length += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, GlobalUint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              GlobalUint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, GlobalUint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof GlobalUint8Array.prototype.indexOf === "function") {
            if (dir) {
              return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i;
        for (i = 0; i < length; ++i) {
          const parsed = parseInt(string.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer2.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          GlobalUint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length; ++i) {
          codePoint = string.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i;
        for (i = 0; i < length; ++i) {
          if (i + offset >= dst.length || i >= src.length)
            break;
          dst[i + offset] = src[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js
  var require_browser = __commonJS({
    "node_modules/.pnpm/process@0.11.10/node_modules/process/browser.js"(exports, module) {
      init_dist();
      var process = module.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function(name) {
        return [];
      };
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function() {
        return 0;
      };
    }
  });

  // shims/dist/index.js
  var import_buffer_polyfill, import_process, o;
  var init_dist = __esm({
    "shims/dist/index.js"() {
      "use strict";
      import_buffer_polyfill = __toESM(require_buffer(), 1);
      import_process = __toESM(require_browser(), 1);
      o = globalThis || void 0 || self;
    }
  });

  // shims/banner/index.cjs
  var require_banner = __commonJS({
    "shims/banner/index.cjs"() {
      init_dist();
      globalThis.Buffer = globalThis.Buffer || import_buffer_polyfill.Buffer;
      globalThis.global = globalThis.global || o;
      globalThis.process = globalThis.process || import_process.default;
    }
  });
  require_banner();
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/

import {
  c,
  c2,
  d as d3,
  f as f3,
  g2 as g,
  g3 as g2,
  g4 as g3,
  j2 as j,
  k2 as k3,
  l2,
  l3,
  p4 as p,
  q,
  u3 as u4,
  u5,
  x2,
  y
} from "./chunk-KFFOLHOG.js";
import {
  e as e2,
  w
} from "./chunk-ZF3VGKIP.js";
import {
  D as D2,
  E as E2,
  I as I2,
  d as d2,
  f as f4,
  f2 as f5,
  l as l4,
  m as m2,
  m2 as m3,
  x as x3
} from "./chunk-7L5TOKQV.js";
import {
  G as G3,
  o as o3
} from "./chunk-QOMWKJSE.js";
import {
  C,
  D,
  E,
  I,
  N,
  P,
  R,
  T,
  _,
  a,
  d,
  e,
  i,
  k,
  l,
  u,
  x
} from "./chunk-FQGQ2ZCA.js";
import {
  C as C2,
  F,
  G,
  G2,
  H,
  O2 as O,
  S,
  T as T2,
  T2 as T3,
  U,
  U2,
  a3 as a2,
  f3 as f2,
  i2,
  m3 as m,
  o,
  require_lib,
  require_out as require_out2,
  t,
  u as u3
} from "./chunk-GQIV3GTG.js";
import {
  f,
  k as k2,
  o as o2,
  u as u2
} from "./chunk-OASOLY3W.js";
import {
  Q
} from "./chunk-E4B7E23H.js";
import {
  Dr,
  Et,
  W,
  v,
  xt,
  yt
} from "./chunk-3PVAC57W.js";
import {
  require_out
} from "./chunk-6LEHUMWJ.js";
import {
  require_react
} from "./chunk-6U3LLJ7Y.js";
import {
  __toESM,
  require_dist
} from "./chunk-CBZXSIYX.js";

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-PIZOI42D.js
var import_dist = __toESM(require_dist());
var $;
var m4 = Dr(() => {
  v();
  x2();
  $ = (n5) => {
    let t12 = new URLSearchParams(n5).toString(), { pathname: o12, hash: r } = f3(), c11 = t12 ? `?${t12}` : "", i11 = o12 ? `${o12}${c11}${r}` : "./";
    setTimeout(() => {
      window == null || window.history.replaceState({}, document == null ? void 0 : document.title, i11);
    });
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-N4YFXMKQ.js
var import_dist2 = __toESM(require_dist());
var p2;
var y2;
var u6 = Dr(() => {
  v();
  m4();
  e2();
  p2 = { search: w() ? window.location.search : "", removeParams: [] }, y2 = (g16, e4 = p2) => {
    var o12;
    let r = {}, P3 = w() ? window.location.search : "", s6 = (o12 = e4.search) != null ? o12 : P3;
    if (s6) {
      let a19 = s6 ? new URLSearchParams(s6) : [];
      r = Object.fromEntries(a19);
    }
    let t12 = {};
    return g16.forEach((a19) => {
      t12[a19] = r[a19], delete r[a19];
    }), e4.removeParams != null && Object.keys(r).forEach((a19) => {
      var n5, c11;
      let [d17] = a19.split("[");
      (((n5 = e4.removeParams) == null ? void 0 : n5.includes(a19)) || ((c11 = e4.removeParams) == null ? void 0 : c11.includes(d17))) && delete r[a19];
    }), { remainingParams: t12, params: r, clearNavigationHistory: () => $(r) };
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-P3EO43BR.js
var import_dist3 = __toESM(require_dist());
var import_qs = __toESM(require_lib());
var N2;
var w2 = Dr(() => {
  v();
  m4();
  e2();
  u6();
  N2 = ({ removeParams: a19, search: r }) => {
    let n5 = w() ? window.location.search : "", e4 = r != null ? r : n5;
    if (!e4)
      return {};
    let c11 = import_qs.default.parse(e4.replace("?", "")), l19 = Object.keys(c11).filter((p21) => !a19.includes(p21)), { remainingParams: o12 } = y2(l19, { search: r, removeParams: a19 });
    return $(o12), o12;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-PUOBJCBI.js
var import_dist4 = __toESM(require_dist());
var import_sdk_web_wallet_provider = __toESM(require_out2());
var R2;
var i3 = Dr(() => {
  v();
  T3();
  w2();
  R2 = ({ transaction: e4, search: s6 }) => N2({ removeParams: [...Object.keys(e4), import_sdk_web_wallet_provider.WALLET_PROVIDER_CALLBACK_PARAM, H, a2], search: s6 });
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-XNFCZFZP.js
var import_dist5 = __toESM(require_dist());
function d4({ tokenId: n5, erdLabel: r }) {
  return Boolean(n5 && n5 !== r);
}
var o4 = Dr(() => {
  v();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-QS2KXUIF.js
var import_dist6 = __toESM(require_dist());
function U3(a19) {
  let e4 = Object.getPrototypeOf(a19).toPlainObject != null ? a19 : D2(a19), n5 = xt(yt({}, e4.toPlainObject()), { hash: e4.getHash().hex(), senderUsername: e4.getSenderUsername().valueOf(), receiverUsername: e4.getReceiverUsername().valueOf(), status: "pending" });
  return G3({ data: n5.data, onlySetGuardian: true }) && (delete n5.senderUsername, delete n5.receiverUsername), n5;
}
var d5 = Dr(() => {
  v();
  m3();
  Q();
  o3();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-X42PRFW5.js
var import_dist7 = __toESM(require_dist());
var R3;
var C3 = Dr(() => {
  v();
  N();
  R3 = { shard: (t12) => `/${e}?shard=${t12}`, receiverShard: (t12) => `/${u}?receivershard=${t12}`, senderShard: (t12) => `/${u}?sendershard=${t12}`, transactionDetails: (t12) => `/${u}/${t12}`, transactionDetailsScResults: (t12) => `/${u}/${t12}/${l}`, transactionDetailsLogs: (t12) => `/${u}/${t12}/${P}`, nodeDetails: (t12) => `/${i}/${t12}`, accountDetails: (t12) => `/${T}/${t12}`, accountDetailsContractCode: (t12) => `/${T}/${t12}/${E}`, accountDetailsTokens: (t12) => `/${T}/${t12}/${k}`, accountDetailsNfts: (t12) => `/${T}/${t12}/${a}`, accountDetailsScResults: (t12) => `/${T}/${t12}/${l}`, accountDetailsContracts: (t12) => `/${T}/${t12}/${D}`, identityDetails: (t12) => `/${_}/${t12}`, tokenDetails: (t12) => `/${k}/${t12}`, tokenDetailsAccounts: (t12) => `/${k}/${t12}/${T}`, tokenDetailsLockedAccounts: (t12) => `/${k}/${t12}/${x}`, tokenDetailsRoles: (t12) => `/${k}/${t12}/${d}`, collectionDetails: (t12) => `/${I}/${t12}`, nftDetails: (t12) => `/${a}/${t12}`, providerDetails: (t12) => `/${R}/${t12}`, providerDetailsTransactions: (t12) => `/${R}/${t12}/${u}`, miniblockDetails: (t12) => `/${C}/${t12}` };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-TGBFLSOH.js
var import_dist8 = __toESM(require_dist());
function x4(o12, e4) {
  let n5, i11, I7 = /(\.0+)+$/, s6 = o12.replace(I7, "").split("."), r = e4.replace(I7, "").split("."), d17 = Math.min(s6.length, r.length);
  for (n5 = 0; n5 < d17; n5++)
    if (i11 = parseInt(s6[n5], 10) - parseInt(r[n5], 10), i11)
      return i11;
  return s6.length - r.length;
}
function a3(o12) {
  let e4 = [S, o, t, U, T2, G, o12].sort((l19, N8) => x4(l19, N8)), n5 = e4.indexOf(S), i11 = e4.indexOf(o), I7 = e4.indexOf(t), s6 = e4.indexOf(U), r = e4.indexOf(T2), d17 = e4.indexOf(G), t12 = e4.indexOf(o12);
  return { ledgerWithMultiAccount: t12 >= n5, ledgerWithHashSign: t12 >= i11, ledgerWithSignAuthToken: t12 >= I7, ledgerWithWhitelistedTokens: t12 >= s6, ledgerWithGuardians: t12 >= r, ledgerWithUsernames: t12 >= d17 };
}
var W2;
var u7 = Dr(() => {
  v();
  T3();
  W2 = a3;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-V7YPFAS3.js
var import_dist9 = __toESM(require_dist());
var f6 = Dr(() => {
  v();
  u7();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-2PW643EQ.js
var import_dist10 = __toESM(require_dist());
var import_sdk_core = __toESM(require_out());
var u8 = Dr(() => {
  v();
  T3();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-7MY34TZZ.js
var import_dist11 = __toESM(require_dist());
var t2;
var p3 = Dr(() => {
  v();
  T3();
  u8();
  t2 = false;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-BQBE7OZR.js
var import_dist12 = __toESM(require_dist());
function n(t12) {
  return { if: function(e4) {
    return e4 ? { then: (p21) => p21 instanceof Function ? n(p21(t12)) : n(p21) } : { then: () => n(t12) };
  }, then: (e4) => e4 instanceof Function ? n(e4(t12)) : n(e4), valueOf: function() {
    return t12;
  } };
}
var a4 = Dr(() => {
  v();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-5DJROO27.js
var import_dist14 = __toESM(require_dist());

// node_modules/bignumber.js/bignumber.mjs
var import_dist13 = __toESM(require_dist(), 1);
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P3 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v5, b3) {
    var alphabet, c11, caseChanged, e4, i11, isNum, len, str, x13 = this;
    if (!(x13 instanceof BigNumber2))
      return new BigNumber2(v5, b3);
    if (b3 == null) {
      if (v5 && v5._isBigNumber === true) {
        x13.s = v5.s;
        if (!v5.c || v5.e > MAX_EXP) {
          x13.c = x13.e = null;
        } else if (v5.e < MIN_EXP) {
          x13.c = [x13.e = 0];
        } else {
          x13.e = v5.e;
          x13.c = v5.c.slice();
        }
        return;
      }
      if ((isNum = typeof v5 == "number") && v5 * 0 == 0) {
        x13.s = 1 / v5 < 0 ? (v5 = -v5, -1) : 1;
        if (v5 === ~~v5) {
          for (e4 = 0, i11 = v5; i11 >= 10; i11 /= 10, e4++)
            ;
          if (e4 > MAX_EXP) {
            x13.c = x13.e = null;
          } else {
            x13.e = e4;
            x13.c = [v5];
          }
          return;
        }
        str = String(v5);
      } else {
        if (!isNumeric.test(str = String(v5)))
          return parseNumeric(x13, str, isNum);
        x13.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e4 = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i11 = str.search(/e/i)) > 0) {
        if (e4 < 0)
          e4 = i11;
        e4 += +str.slice(i11 + 1);
        str = str.substring(0, i11);
      } else if (e4 < 0) {
        e4 = str.length;
      }
    } else {
      intCheck(b3, 2, ALPHABET.length, "Base");
      if (b3 == 10 && alphabetHasNormalDecimalDigits) {
        x13 = new BigNumber2(v5);
        return round(x13, DECIMAL_PLACES + x13.e + 1, ROUNDING_MODE);
      }
      str = String(v5);
      if (isNum = typeof v5 == "number") {
        if (v5 * 0 != 0)
          return parseNumeric(x13, str, isNum, b3);
        x13.s = 1 / v5 < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v5);
        }
      } else {
        x13.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET.slice(0, b3);
      e4 = i11 = 0;
      for (len = str.length; i11 < len; i11++) {
        if (alphabet.indexOf(c11 = str.charAt(i11)) < 0) {
          if (c11 == ".") {
            if (i11 > e4) {
              e4 = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i11 = -1;
              e4 = 0;
              continue;
            }
          }
          return parseNumeric(x13, String(v5), isNum, b3);
        }
      }
      isNum = false;
      str = convertBase(str, b3, 10, x13.s);
      if ((e4 = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      else
        e4 = str.length;
    }
    for (i11 = 0; str.charCodeAt(i11) === 48; i11++)
      ;
    for (len = str.length; str.charCodeAt(--len) === 48; )
      ;
    if (str = str.slice(i11, ++len)) {
      len -= i11;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v5 > MAX_SAFE_INTEGER || v5 !== mathfloor(v5))) {
        throw Error(tooManyDigits + x13.s * v5);
      }
      if ((e4 = e4 - i11 - 1) > MAX_EXP) {
        x13.c = x13.e = null;
      } else if (e4 < MIN_EXP) {
        x13.c = [x13.e = 0];
      } else {
        x13.e = e4;
        x13.c = [];
        i11 = (e4 + 1) % LOG_BASE;
        if (e4 < 0)
          i11 += LOG_BASE;
        if (i11 < len) {
          if (i11)
            x13.c.push(+str.slice(0, i11));
          for (len -= LOG_BASE; i11 < len; ) {
            x13.c.push(+str.slice(i11, i11 += LOG_BASE));
          }
          i11 = LOG_BASE - (str = str.slice(i11)).length;
        } else {
          i11 -= len;
        }
        for (; i11--; str += "0")
          ;
        x13.c.push(+str);
      }
    } else {
      x13.c = [x13.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p21, v5;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p21 = "DECIMAL_PLACES")) {
          v5 = obj[p21];
          intCheck(v5, 0, MAX, p21);
          DECIMAL_PLACES = v5;
        }
        if (obj.hasOwnProperty(p21 = "ROUNDING_MODE")) {
          v5 = obj[p21];
          intCheck(v5, 0, 8, p21);
          ROUNDING_MODE = v5;
        }
        if (obj.hasOwnProperty(p21 = "EXPONENTIAL_AT")) {
          v5 = obj[p21];
          if (v5 && v5.pop) {
            intCheck(v5[0], -MAX, 0, p21);
            intCheck(v5[1], 0, MAX, p21);
            TO_EXP_NEG = v5[0];
            TO_EXP_POS = v5[1];
          } else {
            intCheck(v5, -MAX, MAX, p21);
            TO_EXP_NEG = -(TO_EXP_POS = v5 < 0 ? -v5 : v5);
          }
        }
        if (obj.hasOwnProperty(p21 = "RANGE")) {
          v5 = obj[p21];
          if (v5 && v5.pop) {
            intCheck(v5[0], -MAX, -1, p21);
            intCheck(v5[1], 1, MAX, p21);
            MIN_EXP = v5[0];
            MAX_EXP = v5[1];
          } else {
            intCheck(v5, -MAX, MAX, p21);
            if (v5) {
              MIN_EXP = -(MAX_EXP = v5 < 0 ? -v5 : v5);
            } else {
              throw Error(bignumberError + p21 + " cannot be zero: " + v5);
            }
          }
        }
        if (obj.hasOwnProperty(p21 = "CRYPTO")) {
          v5 = obj[p21];
          if (v5 === !!v5) {
            if (v5) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v5;
              } else {
                CRYPTO = !v5;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v5;
            }
          } else {
            throw Error(bignumberError + p21 + " not true or false: " + v5);
          }
        }
        if (obj.hasOwnProperty(p21 = "MODULO_MODE")) {
          v5 = obj[p21];
          intCheck(v5, 0, 9, p21);
          MODULO_MODE = v5;
        }
        if (obj.hasOwnProperty(p21 = "POW_PRECISION")) {
          v5 = obj[p21];
          intCheck(v5, 0, MAX, p21);
          POW_PRECISION = v5;
        }
        if (obj.hasOwnProperty(p21 = "FORMAT")) {
          v5 = obj[p21];
          if (typeof v5 == "object")
            FORMAT = v5;
          else
            throw Error(bignumberError + p21 + " not an object: " + v5);
        }
        if (obj.hasOwnProperty(p21 = "ALPHABET")) {
          v5 = obj[p21];
          if (typeof v5 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v5)) {
            alphabetHasNormalDecimalDigits = v5.slice(0, 10) == "0123456789";
            ALPHABET = v5;
          } else {
            throw Error(bignumberError + p21 + " invalid: " + v5);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber2.isBigNumber = function(v5) {
    if (!v5 || v5._isBigNumber !== true)
      return false;
    if (!BigNumber2.DEBUG)
      return true;
    var i11, n5, c11 = v5.c, e4 = v5.e, s6 = v5.s;
    out:
      if ({}.toString.call(c11) == "[object Array]") {
        if ((s6 === 1 || s6 === -1) && e4 >= -MAX && e4 <= MAX && e4 === mathfloor(e4)) {
          if (c11[0] === 0) {
            if (e4 === 0 && c11.length === 1)
              return true;
            break out;
          }
          i11 = (e4 + 1) % LOG_BASE;
          if (i11 < 1)
            i11 += LOG_BASE;
          if (String(c11[0]).length == i11) {
            for (i11 = 0; i11 < c11.length; i11++) {
              n5 = c11[i11];
              if (n5 < 0 || n5 >= BASE || n5 !== mathfloor(n5))
                break out;
            }
            if (n5 !== 0)
              return true;
          }
        }
      } else if (c11 === null && e4 === null && (s6 === null || s6 === 1 || s6 === -1)) {
        return true;
      }
    throw Error(bignumberError + "Invalid BigNumber: " + v5);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, -1);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, 1);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a19, b3, e4, k8, v5, i11 = 0, c11 = [], rand = new BigNumber2(ONE);
      if (dp == null)
        dp = DECIMAL_PLACES;
      else
        intCheck(dp, 0, MAX);
      k8 = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a19 = crypto.getRandomValues(new Uint32Array(k8 *= 2));
          for (; i11 < k8; ) {
            v5 = a19[i11] * 131072 + (a19[i11 + 1] >>> 11);
            if (v5 >= 9e15) {
              b3 = crypto.getRandomValues(new Uint32Array(2));
              a19[i11] = b3[0];
              a19[i11 + 1] = b3[1];
            } else {
              c11.push(v5 % 1e14);
              i11 += 2;
            }
          }
          i11 = k8 / 2;
        } else if (crypto.randomBytes) {
          a19 = crypto.randomBytes(k8 *= 7);
          for (; i11 < k8; ) {
            v5 = (a19[i11] & 31) * 281474976710656 + a19[i11 + 1] * 1099511627776 + a19[i11 + 2] * 4294967296 + a19[i11 + 3] * 16777216 + (a19[i11 + 4] << 16) + (a19[i11 + 5] << 8) + a19[i11 + 6];
            if (v5 >= 9e15) {
              crypto.randomBytes(7).copy(a19, i11);
            } else {
              c11.push(v5 % 1e14);
              i11 += 7;
            }
          }
          i11 = k8 / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i11 < k8; ) {
          v5 = random53bitInt();
          if (v5 < 9e15)
            c11[i11++] = v5 % 1e14;
        }
      }
      k8 = c11[--i11];
      dp %= LOG_BASE;
      if (k8 && dp) {
        v5 = POWS_TEN[LOG_BASE - dp];
        c11[i11] = mathfloor(k8 / v5) * v5;
      }
      for (; c11[i11] === 0; c11.pop(), i11--)
        ;
      if (i11 < 0) {
        c11 = [e4 = 0];
      } else {
        for (e4 = -1; c11[0] === 0; c11.splice(0, 1), e4 -= LOG_BASE)
          ;
        for (i11 = 1, v5 = c11[0]; v5 >= 10; v5 /= 10, i11++)
          ;
        if (i11 < LOG_BASE)
          e4 -= LOG_BASE - i11;
      }
      rand.e = e4;
      rand.c = c11;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i11 = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i11 < args.length; )
      sum = sum.plus(args[i11++]);
    return sum;
  };
  convertBase = function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j4, arr = [0], arrL, i11 = 0, len = str.length;
      for (; i11 < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
          ;
        arr[0] += alphabet.indexOf(str.charAt(i11++));
        for (j4 = 0; j4 < arr.length; j4++) {
          if (arr[j4] > baseOut - 1) {
            if (arr[j4 + 1] == null)
              arr[j4 + 1] = 0;
            arr[j4 + 1] += arr[j4] / baseOut | 0;
            arr[j4] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet, d17, e4, k8, r, x13, xc, y10, i11 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i11 >= 0) {
        k8 = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y10 = new BigNumber2(baseIn);
        x13 = y10.pow(str.length - i11);
        POW_PRECISION = k8;
        y10.c = toBaseOut(
          toFixedPoint(coeffToString(x13.c), x13.e, "0"),
          10,
          baseOut,
          decimal
        );
        y10.e = y10.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
      e4 = k8 = xc.length;
      for (; xc[--k8] == 0; xc.pop())
        ;
      if (!xc[0])
        return alphabet.charAt(0);
      if (i11 < 0) {
        --e4;
      } else {
        x13.c = xc;
        x13.e = e4;
        x13.s = sign;
        x13 = div(x13, y10, dp, rm, baseOut);
        xc = x13.c;
        r = x13.r;
        e4 = x13.e;
      }
      d17 = e4 + dp + 1;
      i11 = xc[d17];
      k8 = baseOut / 2;
      r = r || d17 < 0 || xc[d17 + 1] != null;
      r = rm < 4 ? (i11 != null || r) && (rm == 0 || rm == (x13.s < 0 ? 3 : 2)) : i11 > k8 || i11 == k8 && (rm == 4 || r || rm == 6 && xc[d17 - 1] & 1 || rm == (x13.s < 0 ? 8 : 7));
      if (d17 < 1 || !xc[0]) {
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d17;
        if (r) {
          for (--baseOut; ++xc[--d17] > baseOut; ) {
            xc[d17] = 0;
            if (!d17) {
              ++e4;
              xc = [1].concat(xc);
            }
          }
        }
        for (k8 = xc.length; !xc[--k8]; )
          ;
        for (i11 = 0, str = ""; i11 <= k8; str += alphabet.charAt(xc[i11++]))
          ;
        str = toFixedPoint(str, e4, alphabet.charAt(0));
      }
      return str;
    };
  }();
  div = function() {
    function multiply(x13, k8, base) {
      var m12, temp, xlo, xhi, carry = 0, i11 = x13.length, klo = k8 % SQRT_BASE, khi = k8 / SQRT_BASE | 0;
      for (x13 = x13.slice(); i11--; ) {
        xlo = x13[i11] % SQRT_BASE;
        xhi = x13[i11] / SQRT_BASE | 0;
        m12 = khi * xlo + xhi * klo;
        temp = klo * xlo + m12 % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m12 / SQRT_BASE | 0) + khi * xhi;
        x13[i11] = temp % base;
      }
      if (carry)
        x13 = [carry].concat(x13);
      return x13;
    }
    function compare2(a19, b3, aL, bL) {
      var i11, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i11 = cmp = 0; i11 < aL; i11++) {
          if (a19[i11] != b3[i11]) {
            cmp = a19[i11] > b3[i11] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a19, b3, aL, base) {
      var i11 = 0;
      for (; aL--; ) {
        a19[aL] -= i11;
        i11 = a19[aL] < b3[aL] ? 1 : 0;
        a19[aL] = i11 * base + a19[aL] - b3[aL];
      }
      for (; !a19[0] && a19.length > 1; a19.splice(0, 1))
        ;
    }
    return function(x13, y10, dp, rm, base) {
      var cmp, e4, i11, more, n5, prod, prodL, q4, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s6 = x13.s == y10.s ? 1 : -1, xc = x13.c, yc = y10.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x13.s || !y10.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s6 * 0 : s6 / 0
          )
        );
      }
      q4 = new BigNumber2(s6);
      qc = q4.c = [];
      e4 = x13.e - y10.e;
      s6 = dp + e4 + 1;
      if (!base) {
        base = BASE;
        e4 = bitFloor(x13.e / LOG_BASE) - bitFloor(y10.e / LOG_BASE);
        s6 = s6 / LOG_BASE | 0;
      }
      for (i11 = 0; yc[i11] == (xc[i11] || 0); i11++)
        ;
      if (yc[i11] > (xc[i11] || 0))
        e4--;
      if (s6 < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i11 = 0;
        s6 += 2;
        n5 = mathfloor(base / (yc[0] + 1));
        if (n5 > 1) {
          yc = multiply(yc, n5, base);
          xc = multiply(xc, n5, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0)
          ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2)
          yc0++;
        do {
          n5 = 0;
          cmp = compare2(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            n5 = mathfloor(rem0 / yc0);
            if (n5 > 1) {
              if (n5 >= base)
                n5 = base - 1;
              prod = multiply(yc, n5, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n5--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n5 == 0) {
                cmp = n5 = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL)
              prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc, rem, yL, remL) < 1) {
                n5++;
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n5++;
            rem = [0];
          }
          qc[i11++] = n5;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s6--);
        more = rem[0] != null;
        if (!qc[0])
          qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i11 = 1, s6 = qc[0]; s6 >= 10; s6 /= 10, i11++)
          ;
        round(q4, dp + (q4.e = i11 + e4 * LOG_BASE - 1) + 1, rm, more);
      } else {
        q4.e = e4;
        q4.r = +more;
      }
      return q4;
    };
  }();
  function format(n5, i11, rm, id) {
    var c0, e4, ne, len, str;
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    if (!n5.c)
      return n5.toString();
    c0 = n5.c[0];
    ne = n5.e;
    if (i11 == null) {
      str = coeffToString(n5.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n5 = round(new BigNumber2(n5), i11, rm);
      e4 = n5.e;
      str = coeffToString(n5.c);
      len = str.length;
      if (id == 1 || id == 2 && (i11 <= e4 || e4 <= TO_EXP_NEG)) {
        for (; len < i11; str += "0", len++)
          ;
        str = toExponential(str, e4);
      } else {
        i11 -= ne;
        str = toFixedPoint(str, e4, "0");
        if (e4 + 1 > len) {
          if (--i11 > 0)
            for (str += "."; i11--; str += "0")
              ;
        } else {
          i11 += e4 - len;
          if (i11 > 0) {
            if (e4 + 1 == len)
              str += ".";
            for (; i11--; str += "0")
              ;
          }
        }
      }
    }
    return n5.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, n5) {
    var k8, y10, i11 = 1, x13 = new BigNumber2(args[0]);
    for (; i11 < args.length; i11++) {
      y10 = new BigNumber2(args[i11]);
      if (!y10.s || (k8 = compare(x13, y10)) === n5 || k8 === 0 && x13.s === n5) {
        x13 = y10;
      }
    }
    return x13;
  }
  function normalise(n5, c11, e4) {
    var i11 = 1, j4 = c11.length;
    for (; !c11[--j4]; c11.pop())
      ;
    for (j4 = c11[0]; j4 >= 10; j4 /= 10, i11++)
      ;
    if ((e4 = i11 + e4 * LOG_BASE - 1) > MAX_EXP) {
      n5.c = n5.e = null;
    } else if (e4 < MIN_EXP) {
      n5.c = [n5.e = 0];
    } else {
      n5.e = e4;
      n5.c = c11;
    }
    return n5;
  }
  parseNumeric = function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x13, str, isNum, b3) {
      var base, s6 = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s6)) {
        x13.s = isNaN(s6) ? null : s6 < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s6 = s6.replace(basePrefix, function(m12, p1, p22) {
            base = (p22 = p22.toLowerCase()) == "x" ? 16 : p22 == "b" ? 2 : 8;
            return !b3 || b3 == base ? p1 : m12;
          });
          if (b3) {
            base = b3;
            s6 = s6.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s6)
            return new BigNumber2(s6, base);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b3 ? " base " + b3 : "") + " number: " + str);
        }
        x13.s = null;
      }
      x13.c = x13.e = null;
    };
  }();
  function round(x13, sd, rm, r) {
    var d17, i11, j4, k8, n5, ni, rd, xc = x13.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d17 = 1, k8 = xc[0]; k8 >= 10; k8 /= 10, d17++)
          ;
        i11 = sd - d17;
        if (i11 < 0) {
          i11 += LOG_BASE;
          j4 = sd;
          n5 = xc[ni = 0];
          rd = mathfloor(n5 / pows10[d17 - j4 - 1] % 10);
        } else {
          ni = mathceil((i11 + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r) {
              for (; xc.length <= ni; xc.push(0))
                ;
              n5 = rd = 0;
              d17 = 1;
              i11 %= LOG_BASE;
              j4 = i11 - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n5 = k8 = xc[ni];
            for (d17 = 1; k8 >= 10; k8 /= 10, d17++)
              ;
            i11 %= LOG_BASE;
            j4 = i11 - LOG_BASE + d17;
            rd = j4 < 0 ? 0 : mathfloor(n5 / pows10[d17 - j4 - 1] % 10);
          }
        }
        r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j4 < 0 ? n5 : n5 % pows10[d17 - j4 - 1]);
        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x13.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i11 > 0 ? j4 > 0 ? n5 / pows10[d17 - j4] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x13.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r) {
            sd -= x13.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x13.e = -sd || 0;
          } else {
            xc[0] = x13.e = 0;
          }
          return x13;
        }
        if (i11 == 0) {
          xc.length = ni;
          k8 = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k8 = pows10[LOG_BASE - i11];
          xc[ni] = j4 > 0 ? mathfloor(n5 / pows10[d17 - j4] % pows10[j4]) * k8 : 0;
        }
        if (r) {
          for (; ; ) {
            if (ni == 0) {
              for (i11 = 1, j4 = xc[0]; j4 >= 10; j4 /= 10, i11++)
                ;
              j4 = xc[0] += k8;
              for (k8 = 1; j4 >= 10; j4 /= 10, k8++)
                ;
              if (i11 != k8) {
                x13.e++;
                if (xc[0] == BASE)
                  xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k8;
              if (xc[ni] != BASE)
                break;
              xc[ni--] = 0;
              k8 = 1;
            }
          }
        }
        for (i11 = xc.length; xc[--i11] === 0; xc.pop())
          ;
      }
      if (x13.e > MAX_EXP) {
        x13.c = x13.e = null;
      } else if (x13.e < MIN_EXP) {
        x13.c = [x13.e = 0];
      }
    }
    return x13;
  }
  function valueOf(n5) {
    var str, e4 = n5.e;
    if (e4 === null)
      return n5.toString();
    str = coeffToString(n5.c);
    str = e4 <= TO_EXP_NEG || e4 >= TO_EXP_POS ? toExponential(str, e4) : toFixedPoint(str, e4, "0");
    return n5.s < 0 ? "-" + str : str;
  }
  P3.absoluteValue = P3.abs = function() {
    var x13 = new BigNumber2(this);
    if (x13.s < 0)
      x13.s = 1;
    return x13;
  };
  P3.comparedTo = function(y10, b3) {
    return compare(this, new BigNumber2(y10, b3));
  };
  P3.decimalPlaces = P3.dp = function(dp, rm) {
    var c11, n5, v5, x13 = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x13), dp + x13.e + 1, rm);
    }
    if (!(c11 = x13.c))
      return null;
    n5 = ((v5 = c11.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v5 = c11[v5])
      for (; v5 % 10 == 0; v5 /= 10, n5--)
        ;
    if (n5 < 0)
      n5 = 0;
    return n5;
  };
  P3.dividedBy = P3.div = function(y10, b3) {
    return div(this, new BigNumber2(y10, b3), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P3.dividedToIntegerBy = P3.idiv = function(y10, b3) {
    return div(this, new BigNumber2(y10, b3), 0, 1);
  };
  P3.exponentiatedBy = P3.pow = function(n5, m12) {
    var half, isModExp, i11, k8, more, nIsBig, nIsNeg, nIsOdd, y10, x13 = this;
    n5 = new BigNumber2(n5);
    if (n5.c && !n5.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n5));
    }
    if (m12 != null)
      m12 = new BigNumber2(m12);
    nIsBig = n5.e > 14;
    if (!x13.c || !x13.c[0] || x13.c[0] == 1 && !x13.e && x13.c.length == 1 || !n5.c || !n5.c[0]) {
      y10 = new BigNumber2(Math.pow(+valueOf(x13), nIsBig ? n5.s * (2 - isOdd(n5)) : +valueOf(n5)));
      return m12 ? y10.mod(m12) : y10;
    }
    nIsNeg = n5.s < 0;
    if (m12) {
      if (m12.c ? !m12.c[0] : !m12.s)
        return new BigNumber2(NaN);
      isModExp = !nIsNeg && x13.isInteger() && m12.isInteger();
      if (isModExp)
        x13 = x13.mod(m12);
    } else if (n5.e > 9 && (x13.e > 0 || x13.e < -1 || (x13.e == 0 ? x13.c[0] > 1 || nIsBig && x13.c[1] >= 24e7 : x13.c[0] < 8e13 || nIsBig && x13.c[0] <= 9999975e7))) {
      k8 = x13.s < 0 && isOdd(n5) ? -0 : 0;
      if (x13.e > -1)
        k8 = 1 / k8;
      return new BigNumber2(nIsNeg ? 1 / k8 : k8);
    } else if (POW_PRECISION) {
      k8 = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg)
        n5.s = 1;
      nIsOdd = isOdd(n5);
    } else {
      i11 = Math.abs(+valueOf(n5));
      nIsOdd = i11 % 2;
    }
    y10 = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y10 = y10.times(x13);
        if (!y10.c)
          break;
        if (k8) {
          if (y10.c.length > k8)
            y10.c.length = k8;
        } else if (isModExp) {
          y10 = y10.mod(m12);
        }
      }
      if (i11) {
        i11 = mathfloor(i11 / 2);
        if (i11 === 0)
          break;
        nIsOdd = i11 % 2;
      } else {
        n5 = n5.times(half);
        round(n5, n5.e + 1, 1);
        if (n5.e > 14) {
          nIsOdd = isOdd(n5);
        } else {
          i11 = +valueOf(n5);
          if (i11 === 0)
            break;
          nIsOdd = i11 % 2;
        }
      }
      x13 = x13.times(x13);
      if (k8) {
        if (x13.c && x13.c.length > k8)
          x13.c.length = k8;
      } else if (isModExp) {
        x13 = x13.mod(m12);
      }
    }
    if (isModExp)
      return y10;
    if (nIsNeg)
      y10 = ONE.div(y10);
    return m12 ? y10.mod(m12) : k8 ? round(y10, POW_PRECISION, ROUNDING_MODE, more) : y10;
  };
  P3.integerValue = function(rm) {
    var n5 = new BigNumber2(this);
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    return round(n5, n5.e + 1, rm);
  };
  P3.isEqualTo = P3.eq = function(y10, b3) {
    return compare(this, new BigNumber2(y10, b3)) === 0;
  };
  P3.isFinite = function() {
    return !!this.c;
  };
  P3.isGreaterThan = P3.gt = function(y10, b3) {
    return compare(this, new BigNumber2(y10, b3)) > 0;
  };
  P3.isGreaterThanOrEqualTo = P3.gte = function(y10, b3) {
    return (b3 = compare(this, new BigNumber2(y10, b3))) === 1 || b3 === 0;
  };
  P3.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P3.isLessThan = P3.lt = function(y10, b3) {
    return compare(this, new BigNumber2(y10, b3)) < 0;
  };
  P3.isLessThanOrEqualTo = P3.lte = function(y10, b3) {
    return (b3 = compare(this, new BigNumber2(y10, b3))) === -1 || b3 === 0;
  };
  P3.isNaN = function() {
    return !this.s;
  };
  P3.isNegative = function() {
    return this.s < 0;
  };
  P3.isPositive = function() {
    return this.s > 0;
  };
  P3.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P3.minus = function(y10, b3) {
    var i11, j4, t12, xLTy, x13 = this, a19 = x13.s;
    y10 = new BigNumber2(y10, b3);
    b3 = y10.s;
    if (!a19 || !b3)
      return new BigNumber2(NaN);
    if (a19 != b3) {
      y10.s = -b3;
      return x13.plus(y10);
    }
    var xe = x13.e / LOG_BASE, ye = y10.e / LOG_BASE, xc = x13.c, yc = y10.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return xc ? (y10.s = -b3, y10) : new BigNumber2(yc ? x13 : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y10.s = -b3, y10) : new BigNumber2(xc[0] ? x13 : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a19 = xe - ye) {
      if (xLTy = a19 < 0) {
        a19 = -a19;
        t12 = xc;
      } else {
        ye = xe;
        t12 = yc;
      }
      t12.reverse();
      for (b3 = a19; b3--; t12.push(0))
        ;
      t12.reverse();
    } else {
      j4 = (xLTy = (a19 = xc.length) < (b3 = yc.length)) ? a19 : b3;
      for (a19 = b3 = 0; b3 < j4; b3++) {
        if (xc[b3] != yc[b3]) {
          xLTy = xc[b3] < yc[b3];
          break;
        }
      }
    }
    if (xLTy) {
      t12 = xc;
      xc = yc;
      yc = t12;
      y10.s = -y10.s;
    }
    b3 = (j4 = yc.length) - (i11 = xc.length);
    if (b3 > 0)
      for (; b3--; xc[i11++] = 0)
        ;
    b3 = BASE - 1;
    for (; j4 > a19; ) {
      if (xc[--j4] < yc[j4]) {
        for (i11 = j4; i11 && !xc[--i11]; xc[i11] = b3)
          ;
        --xc[i11];
        xc[j4] += BASE;
      }
      xc[j4] -= yc[j4];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye)
      ;
    if (!xc[0]) {
      y10.s = ROUNDING_MODE == 3 ? -1 : 1;
      y10.c = [y10.e = 0];
      return y10;
    }
    return normalise(y10, xc, ye);
  };
  P3.modulo = P3.mod = function(y10, b3) {
    var q4, s6, x13 = this;
    y10 = new BigNumber2(y10, b3);
    if (!x13.c || !y10.s || y10.c && !y10.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y10.c || x13.c && !x13.c[0]) {
      return new BigNumber2(x13);
    }
    if (MODULO_MODE == 9) {
      s6 = y10.s;
      y10.s = 1;
      q4 = div(x13, y10, 0, 3);
      y10.s = s6;
      q4.s *= s6;
    } else {
      q4 = div(x13, y10, 0, MODULO_MODE);
    }
    y10 = x13.minus(q4.times(y10));
    if (!y10.c[0] && MODULO_MODE == 1)
      y10.s = x13.s;
    return y10;
  };
  P3.multipliedBy = P3.times = function(y10, b3) {
    var c11, e4, i11, j4, k8, m12, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x13 = this, xc = x13.c, yc = (y10 = new BigNumber2(y10, b3)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x13.s || !y10.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y10.c = y10.e = y10.s = null;
      } else {
        y10.s *= x13.s;
        if (!xc || !yc) {
          y10.c = y10.e = null;
        } else {
          y10.c = [0];
          y10.e = 0;
        }
      }
      return y10;
    }
    e4 = bitFloor(x13.e / LOG_BASE) + bitFloor(y10.e / LOG_BASE);
    y10.s *= x13.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL) {
      zc = xc;
      xc = yc;
      yc = zc;
      i11 = xcL;
      xcL = ycL;
      ycL = i11;
    }
    for (i11 = xcL + ycL, zc = []; i11--; zc.push(0))
      ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i11 = ycL; --i11 >= 0; ) {
      c11 = 0;
      ylo = yc[i11] % sqrtBase;
      yhi = yc[i11] / sqrtBase | 0;
      for (k8 = xcL, j4 = i11 + k8; j4 > i11; ) {
        xlo = xc[--k8] % sqrtBase;
        xhi = xc[k8] / sqrtBase | 0;
        m12 = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m12 % sqrtBase * sqrtBase + zc[j4] + c11;
        c11 = (xlo / base | 0) + (m12 / sqrtBase | 0) + yhi * xhi;
        zc[j4--] = xlo % base;
      }
      zc[j4] = c11;
    }
    if (c11) {
      ++e4;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y10, zc, e4);
  };
  P3.negated = function() {
    var x13 = new BigNumber2(this);
    x13.s = -x13.s || null;
    return x13;
  };
  P3.plus = function(y10, b3) {
    var t12, x13 = this, a19 = x13.s;
    y10 = new BigNumber2(y10, b3);
    b3 = y10.s;
    if (!a19 || !b3)
      return new BigNumber2(NaN);
    if (a19 != b3) {
      y10.s = -b3;
      return x13.minus(y10);
    }
    var xe = x13.e / LOG_BASE, ye = y10.e / LOG_BASE, xc = x13.c, yc = y10.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return new BigNumber2(a19 / 0);
      if (!xc[0] || !yc[0])
        return yc[0] ? y10 : new BigNumber2(xc[0] ? x13 : a19 * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a19 = xe - ye) {
      if (a19 > 0) {
        ye = xe;
        t12 = yc;
      } else {
        a19 = -a19;
        t12 = xc;
      }
      t12.reverse();
      for (; a19--; t12.push(0))
        ;
      t12.reverse();
    }
    a19 = xc.length;
    b3 = yc.length;
    if (a19 - b3 < 0) {
      t12 = yc;
      yc = xc;
      xc = t12;
      b3 = a19;
    }
    for (a19 = 0; b3; ) {
      a19 = (xc[--b3] = xc[b3] + yc[b3] + a19) / BASE | 0;
      xc[b3] = BASE === xc[b3] ? 0 : xc[b3] % BASE;
    }
    if (a19) {
      xc = [a19].concat(xc);
      ++ye;
    }
    return normalise(y10, xc, ye);
  };
  P3.precision = P3.sd = function(sd, rm) {
    var c11, n5, v5, x13 = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x13), sd, rm);
    }
    if (!(c11 = x13.c))
      return null;
    v5 = c11.length - 1;
    n5 = v5 * LOG_BASE + 1;
    if (v5 = c11[v5]) {
      for (; v5 % 10 == 0; v5 /= 10, n5--)
        ;
      for (v5 = c11[0]; v5 >= 10; v5 /= 10, n5++)
        ;
    }
    if (sd && x13.e + 1 > n5)
      n5 = x13.e + 1;
    return n5;
  };
  P3.shiftedBy = function(k8) {
    intCheck(k8, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k8);
  };
  P3.squareRoot = P3.sqrt = function() {
    var m12, n5, r, rep, t12, x13 = this, c11 = x13.c, s6 = x13.s, e4 = x13.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s6 !== 1 || !c11 || !c11[0]) {
      return new BigNumber2(!s6 || s6 < 0 && (!c11 || c11[0]) ? NaN : c11 ? x13 : 1 / 0);
    }
    s6 = Math.sqrt(+valueOf(x13));
    if (s6 == 0 || s6 == 1 / 0) {
      n5 = coeffToString(c11);
      if ((n5.length + e4) % 2 == 0)
        n5 += "0";
      s6 = Math.sqrt(+n5);
      e4 = bitFloor((e4 + 1) / 2) - (e4 < 0 || e4 % 2);
      if (s6 == 1 / 0) {
        n5 = "5e" + e4;
      } else {
        n5 = s6.toExponential();
        n5 = n5.slice(0, n5.indexOf("e") + 1) + e4;
      }
      r = new BigNumber2(n5);
    } else {
      r = new BigNumber2(s6 + "");
    }
    if (r.c[0]) {
      e4 = r.e;
      s6 = e4 + dp;
      if (s6 < 3)
        s6 = 0;
      for (; ; ) {
        t12 = r;
        r = half.times(t12.plus(div(x13, t12, dp, 1)));
        if (coeffToString(t12.c).slice(0, s6) === (n5 = coeffToString(r.c)).slice(0, s6)) {
          if (r.e < e4)
            --s6;
          n5 = n5.slice(s6 - 3, s6 + 1);
          if (n5 == "9999" || !rep && n5 == "4999") {
            if (!rep) {
              round(t12, t12.e + DECIMAL_PLACES + 2, 0);
              if (t12.times(t12).eq(x13)) {
                r = t12;
                break;
              }
            }
            dp += 4;
            s6 += 4;
            rep = 1;
          } else {
            if (!+n5 || !+n5.slice(1) && n5.charAt(0) == "5") {
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m12 = !r.times(r).eq(x13);
            }
            break;
          }
        }
      }
    }
    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m12);
  };
  P3.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P3.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P3.toFormat = function(dp, rm, format2) {
    var str, x13 = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x13.toFixed(dp, rm);
    if (x13.c) {
      var i11, arr = str.split("."), g1 = +format2.groupSize, g22 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x13.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g22) {
        i11 = g1;
        g1 = g22;
        g22 = i11;
        len -= i11;
      }
      if (g1 > 0 && len > 0) {
        i11 = len % g1 || g1;
        intPart = intDigits.substr(0, i11);
        for (; i11 < len; i11 += g1)
          intPart += groupSeparator + intDigits.substr(i11, g1);
        if (g22 > 0)
          intPart += groupSeparator + intDigits.slice(i11);
        if (isNeg)
          intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g22 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g22 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P3.toFraction = function(md) {
    var d17, d0, d1, d22, e4, exp, n5, n0, n1, q4, r, s6, x13 = this, xc = x13.c;
    if (md != null) {
      n5 = new BigNumber2(md);
      if (!n5.isInteger() && (n5.c || n5.s !== 1) || n5.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n5.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n5));
      }
    }
    if (!xc)
      return new BigNumber2(x13);
    d17 = new BigNumber2(ONE);
    n1 = d0 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s6 = coeffToString(xc);
    e4 = d17.e = s6.length - x13.e - 1;
    d17.c[0] = POWS_TEN[(exp = e4 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n5.comparedTo(d17) > 0 ? e4 > 0 ? d17 : n1 : n5;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n5 = new BigNumber2(s6);
    n0.c[0] = 0;
    for (; ; ) {
      q4 = div(n5, d17, 0, 1);
      d22 = d0.plus(q4.times(d1));
      if (d22.comparedTo(md) == 1)
        break;
      d0 = d1;
      d1 = d22;
      n1 = n0.plus(q4.times(d22 = n1));
      n0 = d22;
      d17 = n5.minus(q4.times(d22 = d17));
      n5 = d22;
    }
    d22 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d22.times(n1));
    d0 = d0.plus(d22.times(d1));
    n0.s = n1.s = x13.s;
    e4 = e4 * 2;
    r = div(n1, d1, e4, ROUNDING_MODE).minus(x13).abs().comparedTo(
      div(n0, d0, e4, ROUNDING_MODE).minus(x13).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r;
  };
  P3.toNumber = function() {
    return +valueOf(this);
  };
  P3.toPrecision = function(sd, rm) {
    if (sd != null)
      intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P3.toString = function(b3) {
    var str, n5 = this, s6 = n5.s, e4 = n5.e;
    if (e4 === null) {
      if (s6) {
        str = "Infinity";
        if (s6 < 0)
          str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b3 == null) {
        str = e4 <= TO_EXP_NEG || e4 >= TO_EXP_POS ? toExponential(coeffToString(n5.c), e4) : toFixedPoint(coeffToString(n5.c), e4, "0");
      } else if (b3 === 10 && alphabetHasNormalDecimalDigits) {
        n5 = round(new BigNumber2(n5), DECIMAL_PLACES + e4 + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n5.c), n5.e, "0");
      } else {
        intCheck(b3, 2, ALPHABET.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n5.c), e4, "0"), 10, b3, s6, true);
      }
      if (s6 < 0 && n5.c[0])
        str = "-" + str;
    }
    return str;
  };
  P3.valueOf = P3.toJSON = function() {
    return valueOf(this);
  };
  P3._isBigNumber = true;
  P3[Symbol.toStringTag] = "BigNumber";
  P3[Symbol.for("nodejs.util.inspect.custom")] = P3.valueOf;
  if (configObject != null)
    BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n5) {
  var i11 = n5 | 0;
  return n5 > 0 || n5 === i11 ? i11 : i11 - 1;
}
function coeffToString(a19) {
  var s6, z, i11 = 1, j4 = a19.length, r = a19[0] + "";
  for (; i11 < j4; ) {
    s6 = a19[i11++] + "";
    z = LOG_BASE - s6.length;
    for (; z--; s6 = "0" + s6)
      ;
    r += s6;
  }
  for (j4 = r.length; r.charCodeAt(--j4) === 48; )
    ;
  return r.slice(0, j4 + 1 || 1);
}
function compare(x13, y10) {
  var a19, b3, xc = x13.c, yc = y10.c, i11 = x13.s, j4 = y10.s, k8 = x13.e, l19 = y10.e;
  if (!i11 || !j4)
    return null;
  a19 = xc && !xc[0];
  b3 = yc && !yc[0];
  if (a19 || b3)
    return a19 ? b3 ? 0 : -j4 : i11;
  if (i11 != j4)
    return i11;
  a19 = i11 < 0;
  b3 = k8 == l19;
  if (!xc || !yc)
    return b3 ? 0 : !xc ^ a19 ? 1 : -1;
  if (!b3)
    return k8 > l19 ^ a19 ? 1 : -1;
  j4 = (k8 = xc.length) < (l19 = yc.length) ? k8 : l19;
  for (i11 = 0; i11 < j4; i11++)
    if (xc[i11] != yc[i11])
      return xc[i11] > yc[i11] ^ a19 ? 1 : -1;
  return k8 == l19 ? 0 : k8 > l19 ^ a19 ? 1 : -1;
}
function intCheck(n5, min, max, name) {
  if (n5 < min || n5 > max || n5 !== mathfloor(n5)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n5 == "number" ? n5 < min || n5 > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n5));
  }
}
function isOdd(n5) {
  var k8 = n5.c.length - 1;
  return bitFloor(n5.e / LOG_BASE) == k8 && n5.c[k8] % 2 != 0;
}
function toExponential(str, e4) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e4 < 0 ? "e" : "e+") + e4;
}
function toFixedPoint(str, e4, z) {
  var len, zs;
  if (e4 < 0) {
    for (zs = z + "."; ++e4; zs += z)
      ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e4 > len) {
      for (zs = z, e4 -= len; --e4; zs += z)
        ;
      str += zs;
    } else if (e4 < len) {
      str = str.slice(0, e4) + "." + str.slice(e4);
    }
  }
  return str;
}
var BigNumber = clone();
var bignumber_default = BigNumber;

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-5DJROO27.js
var d6;
var c4 = Dr(() => {
  v();
  d6 = (e4, i11 = true) => {
    let t12 = String(e4);
    if (!t12.match(/^[-]?\d+$/))
      return false;
    let r = new bignumber_default(t12), o12 = i11 ? 0 : -1;
    return r.toString(10) === t12 && r.comparedTo(0) >= o12;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-6RTFIOO2.js
var import_dist15 = __toESM(require_dist());
var import_sdk_core2 = __toESM(require_out());
function H2({ input: a19, decimals: c11 = f2, digits: t12 = m, showLastNonZeroDecimal: o12 = true, showIsLessThanDecimalsLabel: T9 = false, addCommas: v5 = false }) {
  if (!d6(a19, false))
    throw new Error("Invalid input");
  let b3 = new bignumber_default(a19).isNegative(), u21 = a19;
  return b3 && (u21 = a19.substring(1)), n(u21).then(() => import_sdk_core2.TokenTransfer.fungibleFromBigInteger("", u21, c11).amountAsBigInteger.shiftedBy(-c11).toFixed(c11)).then((g16) => {
    let h12 = new bignumber_default(g16);
    if (h12.isZero())
      return u3;
    let d17 = h12.toString(10), [F6, n5] = d17.split("."), p21 = new bignumber_default(n5 || 0), $2 = n(0).if(Boolean(n5 && o12)).then(() => Math.max(n5.length, t12)).if(p21.isZero() && !o12).then(0).if(Boolean(n5 && !o12)).then(() => Math.min(n5.length, t12)).valueOf(), B4 = n5 && t12 >= 1 && t12 <= n5.length && p21.isGreaterThan(0) && new bignumber_default(n5.substring(0, t12)).isZero(), y10 = h12.toFormat($2);
    return n(d17).if(v5).then(y10).if(Boolean(B4)).then((s6) => {
      let i11 = new bignumber_default(F6).isZero(), [e4, f26] = s6.split("."), l19 = new Array(t12 - 1).fill(0), E5 = [...l19, 0].join(""), S8 = [...l19, 1].join("");
      return i11 ? T9 ? `<${e4}.${S8}` : o12 ? `${e4}.${f26}` : e4 : `${e4}.${E5}`;
    }).if(Boolean(!B4 && n5)).then((s6) => {
      let [i11] = s6.split("."), e4 = n5.substring(0, $2);
      if (o12) {
        let f26 = t12 - e4.length;
        if (f26 > 0) {
          let l19 = Array(f26).fill(0).join("");
          return e4 = `${e4}${l19}`, `${i11}.${e4}`;
        }
        return s6;
      }
      return e4 ? `${i11}.${e4}` : i11;
    }).valueOf();
  }).if(b3).then((g16) => `-${g16}`).valueOf();
}
var R4 = Dr(() => {
  v();
  T3();
  c4();
  a4();
  bignumber_default.config({ ROUNDING_MODE: bignumber_default.ROUND_FLOOR });
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-YRZKLN43.js
var import_dist16 = __toESM(require_dist());
var d7;
var l5 = Dr(() => {
  v();
  d7 = ({ amount: e4, usd: a19, decimals: t12 = 2, addEqualSign: i11 }) => {
    let o12 = (parseFloat(e4) * a19).toFixed(t12), r = parseFloat(o12).toLocaleString("en", { maximumFractionDigits: t12, minimumFractionDigits: t12 }), s6 = parseFloat(e4) > 0 ? "" : "=";
    return `${i11 ? `${s6} ` : ""}$${r}`;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-EZKJ6SH6.js
var import_dist17 = __toESM(require_dist());
var L;
var p4 = Dr(() => {
  v();
  T3();
  R4();
  l5();
  L = ({ feeLimit: n5, egldPriceInUsd: l19, hideEqualSign: m12 }) => {
    let s6 = H2({ input: n5, decimals: f2, digits: m, showLastNonZeroDecimal: true }), t12 = d7({ amount: s6, usd: l19, decimals: m });
    return m12 ? t12 : ` ${t12}`;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-XYOQ2RUY.js
var import_dist18 = __toESM(require_dist());
var t3;
var p5 = Dr(() => {
  v();
  T3();
  R4();
  t3 = false;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-4M54TFO5.js
var import_dist19 = __toESM(require_dist());
var o5 = Dr(() => {
  v();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-HGEGFQPE.js
var import_dist20 = __toESM(require_dist());
function h(n5) {
  let t12 = Math.floor(n5 / 864e5), s6 = n5 % (24 * 60 * 60 * 1e3), e4 = Math.floor(s6 / (60 * 60 * 1e3)), o12 = s6 % (60 * 60 * 1e3), r = Math.floor(o12 / (60 * 1e3)), T9 = o12 % (60 * 1e3), i11 = Math.floor(T9 / 1e3), c11 = i11 + " sec", f26 = r + " min", u21 = e4 + " hr", g16 = t12 + " day";
  if (i11 > 1 && (c11 = i11 + " sec"), r > 1 && (f26 = r + " min"), e4 > 1 && (u21 = e4 + " hrs"), t12 > 1 && (g16 = t12 + " days"), t12 >= 1)
    return g16 + " " + u21;
  if (e4 >= 1) {
    let a19 = r === 0 ? "" : " " + f26;
    return u21 + a19;
  }
  if (r >= 1) {
    let a19 = i11 === 0 ? "" : " " + c11;
    return f26 + a19;
  }
  return c11;
}
function l6(n5) {
  let t12 = n5.split(" ");
  return t12.length > 1 ? `${t12[0]} ${t12[1]}` : n5;
}
function D3(n5) {
  let s6 = (/* @__PURE__ */ new Date()).getTime() - n5;
  return Math.max(s6, 0);
}
function p6(n5, t12 = true) {
  let s6 = D3(n5), e4 = h(s6);
  return t12 ? l6(e4) : e4;
}
var M;
var U4 = Dr(() => {
  v();
  M = (n5 = /* @__PURE__ */ new Date(), t12 = 0) => Date.UTC(n5.getUTCFullYear(), n5.getUTCMonth(), n5.getUTCDate(), n5.getUTCHours(), n5.getUTCMinutes(), n5.getUTCSeconds() + t12, n5.getUTCMilliseconds());
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-FFC6SFZJ.js
var import_dist21 = __toESM(require_dist());
var I3;
var g5 = Dr(() => {
  v();
  T3();
  I3 = (e4) => {
    if (isNaN(e4) || e4 == null || String(e4).includes("Infinity"))
      return false;
    let [r, t12] = e4.split("."), s6 = bignumber_default.clone();
    if (t12) {
      let a19 = t12.split("").every((f26) => !isNaN(parseInt(f26)));
      for (s6.set({ DECIMAL_PLACES: a19 ? t12.length : bignumber_default.config().DECIMAL_PLACES }); t12.charAt(t12.length - 1) === u3; )
        t12 = t12.slice(0, -1);
    }
    let i11 = t12 ? [r, t12].join(".") : r, n5 = s6(i11);
    return n5.toString(10) === i11 && n5.comparedTo(0) >= 0;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-LXRRORKB.js
var import_dist22 = __toESM(require_dist());
function g6(e4) {
  let n5 = e4 == null ? void 0 : e4.split("-").length;
  return n5 === 2 ? xt(yt({}, l7), { isEsdt: true }) : n5 === 3 ? xt(yt({}, l7), { isNft: true }) : xt(yt({}, l7), { isEgld: true });
}
var l7;
var o6 = Dr(() => {
  v();
  l7 = { isEsdt: false, isNft: false, isEgld: false };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-7ZTPWWGU.js
var import_dist23 = __toESM(require_dist());
var a5;
var f7 = Dr(() => {
  v();
  T3();
  a5 = (n5, r) => {
    let i11 = r === void 0 ? f2 : r;
    return !(n5 != null && n5.toString().indexOf(".") >= 0 && n5.toString().split(".").pop().length > i11);
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-C7HWDSJ5.js
var import_dist24 = __toESM(require_dist());
var t4 = Dr(() => {
  v();
  c4();
  g5();
  f7();
  o6();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-FSQWNG35.js
var import_dist25 = __toESM(require_dist());
var import_sdk_core3 = __toESM(require_out());
function U5({ minGasLimit: t12 = String(O), gasLimit: e4, gasPrice: r, data: k8, gasPerDataByte: G4, gasPriceModifier: I7, defaultGasPrice: v5 = String(C2), chainId: a19 }) {
  let i11 = k8 || "", y10 = d6(e4) ? e4 : t12, T9 = G3({ data: i11 }) ? G2 : 0, h12 = new bignumber_default(y10).plus(T9).toNumber(), L4 = I3(r) ? r : v5, P3 = new import_sdk_core3.Transaction({ nonce: 0, value: import_sdk_core3.TokenPayment.egldFromAmount("0"), receiver: new import_sdk_core3.Address(f8.to), sender: new import_sdk_core3.Address(f8.to), gasPrice: parseInt(L4), gasLimit: h12, data: new import_sdk_core3.TransactionPayload(i11.trim()), chainID: a19, version: new import_sdk_core3.TransactionVersion(1) });
  try {
    return P3.computeFee({ GasPerDataByte: parseInt(G4), MinGasLimit: parseInt(t12), GasPriceModifier: parseFloat(I7), ChainID: a19 }).toString(10);
  } catch (n5) {
    return console.error(n5), u3;
  }
}
var f8;
var j2 = Dr(() => {
  v();
  T3();
  o3();
  t4();
  f8 = { from: "erd12dnfhej64s6c56ka369gkyj3hwv5ms0y5rxgsk2k7hkd2vuk7rvqxkalsa", to: "erd12dnfhej64s6c56ka369gkyj3hwv5ms0y5rxgsk2k7hkd2vuk7rvqxkalsa" };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-AOXIRO72.js
var import_dist26 = __toESM(require_dist());
var h2 = Dr(() => {
  v();
  p5();
  R4();
  p3();
  u8();
  j2();
  l5();
  a4();
  U4();
  o5();
  f6();
  p4();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-LVCWBXY5.js
var import_dist27 = __toESM(require_dist());
var t5;
var s;
var a6 = Dr(() => {
  v();
  t5 = ((r) => (r.FungibleESDT = "FungibleESDT", r))(t5 || {}), s = ((n5) => (n5.NonFungibleESDT = "NonFungibleESDT", n5.SemiFungibleESDT = "SemiFungibleESDT", n5.MetaESDT = "MetaESDT", n5))(s || {});
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-4DIPG5ET.js
var import_dist28 = __toESM(require_dist());
function D4({ token: t12, noValue: n5, showLastNonZeroDecimal: i11 }) {
  var l19;
  let o12 = !n5 && t12.value && t12.type !== "NonFungibleESDT", r = t12.decimals != null, e4 = "";
  t12.type === "NonFungibleESDT" && (e4 = "NFT"), t12.type === "SemiFungibleESDT" && (e4 = "SFT"), t12.type === "MetaESDT" && (e4 = "Meta-ESDT");
  let a19 = "";
  o12 && r && (a19 = r ? H2({ input: t12.value, decimals: t12.decimals, digits: 2, showLastNonZeroDecimal: i11 }) : Number(t12.value).toLocaleString("en"));
  let u21 = R3.nftDetails(String(t12.identifier)), p21 = t12.ticker === t12.collection && (l19 = t12.identifier) != null ? l19 : t12.ticker;
  return { badgeText: e4, tokenFormattedAmount: o12 ? a19 : null, tokenExplorerLink: u21, tokenLinkText: p21, token: t12, noValue: n5, showLastNonZeroDecimal: i11 };
}
var d8 = Dr(() => {
  v();
  a6();
  h2();
  C3();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-L6V2KLRC.js
var import_dist29 = __toESM(require_dist());
function F3({ token: o12, noValue: T9, showLastNonZeroDecimal: n5 }) {
  var e4;
  let t12 = Boolean(!T9 && o12.value), c11 = t12 ? H2({ input: o12.value, decimals: (e4 = o12.decimals) != null ? e4 : f2, digits: 2, showLastNonZeroDecimal: n5, addCommas: true }) : null, l19 = R3.tokenDetails(String(o12.token)), s6 = o12.ticker;
  return { tokenExplorerLink: l19, tokenFormattedAmount: c11, showFormattedAmount: t12, tokenLinkText: s6, token: o12, showLastNonZeroDecimal: n5 };
}
var d9 = Dr(() => {
  v();
  T3();
  h2();
  C3();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-TB2X5ZV4.js
var import_dist30 = __toESM(require_dist());
var h3;
var V = Dr(() => {
  v();
  d8();
  d9();
  o6();
  h3 = (T9) => {
    let u21 = T9.map((e4) => {
      let { isNft: l19 } = g6(e4.type);
      if (l19) {
        let { badgeText: n5, tokenFormattedAmount: c11, tokenLinkText: s6 } = D4({ token: e4 });
        return `${n5 != null ? `(${n5}) ` : ""}${c11} ${s6}`;
      }
      let { tokenFormattedAmount: k8, tokenLinkText: p21, token: t12 } = F3({ token: e4 }), m12 = t12.collection ? t12.identifier : t12.token;
      return `${k8} ${p21} (${m12})`;
    });
    return decodeURI(u21.join("%0A"));
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-EBJYOLNG.js
var import_dist31 = __toESM(require_dist());
var u9;
var l8 = Dr(() => {
  v();
  T3();
  R4();
  u9 = (t12) => ({ egldValueData: { value: t12, formattedValue: H2({ input: t12 }), decimals: f2 } });
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-RHXJ2LRN.js
var import_dist32 = __toESM(require_dist());
function N4(e4) {
  var t12, a19, o12, n5, u21;
  return new bignumber_default((a19 = (t12 = e4.action) == null ? void 0 : t12.arguments) == null ? void 0 : a19.value).isNaN() ? (l9 || (console.error(`Unable to interpret ${(u21 = e4.action) == null ? void 0 : u21.name} data for txHash: ${e4.txHash}`), l9 = true), u9(e4.value)) : u9((n5 = (o12 = e4.action) == null ? void 0 : o12.arguments) == null ? void 0 : n5.value);
}
var l9;
var f9 = Dr(() => {
  v();
  l8();
  l9 = false;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-EHZSMQHW.js
var import_dist33 = __toESM(require_dist());
function y3(e4) {
  var t12;
  try {
    let i11 = E2(e4.data).replace(`${(t12 = e4.action) == null ? void 0 : t12.name}@`, ""), a19 = new bignumber_default(i11, 16);
    if (!a19.isNaN())
      return u9(a19.toString(10));
  } catch (d17) {
    l10 || (console.error(`Unable to extract value for txHash: ${e4.txHash}`), l10 = true);
  }
  return u9(e4.value);
}
var l10;
var f10 = Dr(() => {
  v();
  x3();
  l8();
  l10 = false;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-QOTQ224Y.js
var import_dist34 = __toESM(require_dist());
var u10;
var T4 = Dr(() => {
  v();
  f();
  u10 = (e4) => {
    var r, t12;
    return (t12 = (r = e4 == null ? void 0 : e4.operations) == null ? void 0 : r.filter((o12) => Object.values(k2).includes(o12.type))) != null ? t12 : [];
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-WR7UW653.js
var import_dist35 = __toESM(require_dist());
function h4(e4) {
  try {
    if (e4.operations) {
      let [r] = u10(e4);
      return u9(r == null ? void 0 : r.value);
    } else
      s2(e4.txHash);
  } catch (r) {
    s2(e4.txHash);
  }
  return u9(e4.value);
}
var l11;
var s2;
var f11 = Dr(() => {
  v();
  T4();
  l8();
  l11 = false, s2 = (e4) => {
    l11 || (console.error(`Operations field missing for txHash: ${e4}.
        Unable to compute value field.`), l11 = true);
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-V2OTXVLL.js
var import_dist36 = __toESM(require_dist());
var x5 = Dr(() => {
  v();
  V();
  l8();
  f10();
  f11();
  f9();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-JRB2SSEU.js
var import_dist37 = __toESM(require_dist());
var k4;
var m5 = Dr(() => {
  v();
  k4 = (e4) => {
    var n5, r, t12, o12;
    if (e4.action) {
      let s6 = [(n5 = e4.action.arguments) == null ? void 0 : n5.token, (r = e4.action.arguments) == null ? void 0 : r.token1, (t12 = e4.action.arguments) == null ? void 0 : t12.token2, (o12 = e4.action.arguments) == null ? void 0 : o12.transfers].filter((T9) => T9 != null);
      return [].concat(...s6);
    }
    return [];
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-IVF47HJD.js
var import_dist38 = __toESM(require_dist());
var a7;
var E3;
var N5;
var s3;
var A = Dr(() => {
  v();
  f();
  a7 = ["reDelegateRewards", "claimRewards", "unBond"], E3 = ["wrapEgld", "unwrapEgld"], N5 = ["unStake"], s3 = ["unDelegate"];
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-EKGPN3WI.js
var import_dist39 = __toESM(require_dist());
var te;
var j3 = Dr(() => {
  v();
  T3();
  a6();
  m5();
  d8();
  d9();
  A();
  x5();
  l8();
  V();
  te = ({ transaction: e4, hideMultipleBadge: x13 }) => {
    var l19;
    if (e4.action) {
      if (E3.includes(e4.action.name))
        return u9(e4.value);
      if (N5.includes(e4.action.name))
        return y3(e4);
      if (a7.includes(e4.action.name))
        return h4(e4);
      if (s3.includes(e4.action.name))
        return N4(e4);
      let a19 = k4(e4);
      if (a19.length) {
        let t12 = a19[0], _3 = Object.values(s).includes(t12.type), T9 = !x13 && a19.length > 1 ? h3(a19) : "";
        if (_3) {
          let { badgeText: L4, tokenFormattedAmount: n5, tokenExplorerLink: O2, tokenLinkText: h12 } = D4({ token: t12 });
          return { nftValueData: { badgeText: L4, tokenFormattedAmount: n5, tokenExplorerLink: O2, tokenLinkText: h12, transactionTokens: a19, token: t12, value: n5 != null ? t12.value : null, decimals: n5 != null ? t12.decimals : null, titleText: T9 } };
        }
        let { tokenExplorerLink: y10, showFormattedAmount: E5, tokenFormattedAmount: I7, tokenLinkText: N8, token: F6 } = F3({ token: t12 });
        return { tokenValueData: { tokenExplorerLink: y10, showFormattedAmount: E5, tokenFormattedAmount: I7, tokenLinkText: N8, transactionTokens: a19, token: F6, value: t12.value, decimals: (l19 = t12.decimals) != null ? l19 : f2, titleText: T9 } };
      }
    }
    return u9(e4.value);
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-FZ2R5HQP.js
var import_dist40 = __toESM(require_dist());
var f12 = Dr(() => {
  v();
  j3();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-YV6QV44R.js
var import_dist41 = __toESM(require_dist());
function d10(r, e4, i11) {
  let n5 = r === e4.sender, t12 = r === i11, s6 = n5 && t12, o12 = (e4 == null ? void 0 : e4.type) === "SmartContractResult";
  switch (true) {
    case o12:
      return "Internal";
    case s6:
      return "Self";
    case t12:
      return "In";
    case n5:
    default:
      return "Out";
  }
}
var a8 = Dr(() => {
  v();
  f();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-26GS6QMF.js
var import_dist42 = __toESM(require_dist());
function l12(e4) {
  t6 || (console.error(e4), t6 = true);
}
function g7({ explorerAddress: e4, to: r }) {
  try {
    return new URL(r).href;
  } catch (i11) {
    return r.startsWith("/") || (l12(`Link not prepended by / : ${r}`), r = `/${r}`), e4 ? `${e4}${r}` : r;
  }
}
var t6;
var o7 = Dr(() => {
  v();
  t6 = false;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-U3TQIHS4.js
var import_dist43 = __toESM(require_dist());
function m6(e4) {
  var i11, c11;
  let r = e4.receiver;
  return (c11 = (i11 = e4.action) == null ? void 0 : i11.arguments) != null && c11.receiver && (r = e4.action.arguments.receiver), r;
}
var o8 = Dr(() => {
  v();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-2WP7OVEE.js
var import_dist44 = __toESM(require_dist());
function a9(e4) {
  let n5 = m6(e4);
  return e4.receiver === n5 ? e4.receiverAssets : void 0;
}
var o9 = Dr(() => {
  v();
  o8();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-NGU4IN6H.js
var import_dist45 = __toESM(require_dist());
var v2;
var T5 = Dr(() => {
  v();
  f();
  v2 = (n5) => {
    var a19, o12, e4, i11, c11, r;
    let t12 = "Transaction";
    return ((a19 = n5.action) == null ? void 0 : a19.name) && ((o12 = n5.action) == null ? void 0 : o12.category) && (((e4 = n5.action) == null ? void 0 : e4.category) === "esdtNft" && ((i11 = n5.action) == null ? void 0 : i11.name) === "transfer" ? t12 = "Transaction" : n5.action && (t12 = n5.action.name), (r = (c11 = n5.action) == null ? void 0 : c11.arguments) != null && r.functionName && (t12 = n5.action.arguments.functionName)), t12;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-KWQPHBRJ.js
var import_dist46 = __toESM(require_dist());
function f13(e4) {
  var s6, o12;
  return (o12 = (s6 = e4 == null ? void 0 : e4.operations) == null ? void 0 : s6.map((r) => r.message).filter((r) => Boolean(r))) != null ? o12 : [];
}
var i5 = Dr(() => {
  v();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-5ENHVZNA.js
var import_dist47 = __toESM(require_dist());
function A2(e4) {
  var o12;
  let r = (o12 = e4.receipt) == null ? void 0 : o12.data;
  if (!r)
    return "";
  let t12 = g8(e4), i11 = t12 ? `: ${t12}` : "";
  return `${r}${i11}`;
}
var g8;
var l13 = Dr(() => {
  v();
  T3();
  R4();
  g8 = (e4) => {
    var r, t12;
    if (!((r = e4.receipt) != null && r.value))
      return "";
    if (((t12 = e4.receipt) == null ? void 0 : t12.data) === F) {
      let i11 = H2({ input: e4.receipt.value, decimals: f2, digits: m, showLastNonZeroDecimal: true });
      return new bignumber_default(i11).times(e4.gasPrice).times(100).toFixed();
    }
    return e4.receipt.value;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-7WXEH6OF.js
var import_dist48 = __toESM(require_dist());
function p8(e4) {
  var s6, u21;
  return (u21 = (s6 = e4 == null ? void 0 : e4.results) == null ? void 0 : s6.map((r) => r.returnMessage).filter((r) => Boolean(r))) != null ? u21 : [];
}
var t7 = Dr(() => {
  v();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-N3QTYKLF.js
var import_dist49 = __toESM(require_dist());
function U6({ value: n5, noSeconds: i11, utc: m12, meridiem: t12 = true }) {
  let e4 = new Date(n5 * 1e3), [, a19] = e4.toLocaleString("en-US", { hour: "numeric", hour12: t12 }).split(" "), r = e4.toUTCString(), [, c11] = r.split(","), [s6, u21, f26, l19] = c11.trim().split(" "), [d17, $2, p21] = l19.split(":"), S8 = `:${p21}`, b3 = `${d17}:${$2}${i11 ? "" : S8}`, x13 = `${t12 ? a19 : ""} ${m12 ? "UTC" : ""}`.trim();
  return `${u21} ${s6}, ${f26} ${b3} ${x13}`.trim();
}
var h5 = Dr(() => {
  v();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-TYUFKGBQ.js
var import_dist50 = __toESM(require_dist());
var i6 = Dr(() => {
  v();
  C3();
  m5();
  o9();
  o8();
  T5();
  o7();
  a8();
  C3();
  h5();
  o7();
  i5();
  l13();
  t7();
  o7();
  f12();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-7OWGSABI.js
var import_dist51 = __toESM(require_dist());
var import_sdk_core4 = __toESM(require_out());
function a10(c11) {
  try {
    let r = new import_sdk_core4.Address(c11);
    return Boolean(r.bech32());
  } catch (r) {
    return false;
  }
}
function g9(c11) {
  return (c11 == null ? void 0 : c11.length) === 62 && /^\w+$/.test(c11) && a10(c11);
}
var f14 = Dr(() => {
  v();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-N2BJUOYV.js
var import_dist52 = __toESM(require_dist());
var import_sdk_core5 = __toESM(require_out());
function H3(r, s6, t12 = "") {
  if (!g9(r))
    return false;
  if (new import_sdk_core5.Address(r).isContractAddress())
    return true;
  let i11 = A3({ receiver: r, data: t12 });
  return i11 ? new import_sdk_core5.Address(i11).isContractAddress() || F4(r, s6, t12) : false;
}
function F4(r, s6, t12) {
  let n5 = t12 == null ? void 0 : t12.split("@");
  if (n5 == null)
    return false;
  let [e4, ...i11] = n5, o12 = s6 != null && r != null && r === s6, u21 = C4.includes(e4), f26 = i11.every((a19) => m7(a19) && x6(a19));
  return o12 && u21 && f26;
}
function A3({ receiver: r, data: s6 }) {
  try {
    if (!s6)
      return r;
    let t12 = f5(s6) ? import_sdk_core5.TransactionPayload.fromEncoded(s6).toString() : s6, n5 = y4(t12), e4 = t12.split("@");
    return n5 > -1 ? e4[n5] : r;
  } catch (t12) {
    console.log(t12);
    return;
  }
}
function y4(r) {
  return r.includes("MultiESDTNFTTransfer") ? 1 : r.includes("ESDTNFTTransfer") ? 4 : -1;
}
var C4;
var m7;
var x6;
var N6 = Dr(() => {
  v();
  u2();
  f14();
  d2();
  C4 = ["ESDTNFTTransfer", "ESDTNFTBurn", "ESDTNFTAddQuantity", "ESDTNFTCreate", "MultiESDTNFTTransfer", "ESDTTransfer", "ESDTBurn", "ESDTLocalMint", "ESDTLocalBurn", "ESDTWipe", "ESDTFreeze"];
  m7 = (r) => r.toLowerCase().match(/[0-9a-f]/g), x6 = (r) => r.length % 2 === 0;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-JKEVTNC5.js
var import_dist53 = __toESM(require_dist());
var import_sdk_core6 = __toESM(require_out());
function b2(r) {
  if (!r)
    return c5;
  let i11 = r.startsWith("ESDTTransfer"), a19 = r.startsWith("ESDTNFTTransfer") && r.includes("@"), u21 = r.startsWith("ESDTNFTBurn") && r.includes("@");
  if (i11) {
    let [, n5, t12] = r.split("@");
    try {
      let e4 = W.Buffer.from(n5, "hex").toString("ascii");
      if (!e4)
        return c5;
      let o12 = new bignumber_default("0x" + t12.replace("0x", "")).toString(10);
      return { tokenId: e4, amount: o12 };
    } catch (e4) {
      console.error("Error getting token from transaction data", e4);
    }
  }
  if (a19)
    try {
      let [, n5, t12, e4, o12] = T6(r);
      if ([n5, t12, e4, o12].every((p21) => Boolean(p21)) && g9(new import_sdk_core6.Address(o12).bech32()))
        return { tokenId: `${n5}-${t12}`, amount: new bignumber_default(e4, 16).toString(10), collection: n5, nonce: t12, receiver: new import_sdk_core6.Address(o12).bech32() };
    } catch (n5) {
    }
  if (u21)
    try {
      let [, n5, t12, e4] = T6(r);
      if ([n5, t12, e4].every((o12) => Boolean(o12)))
        return { tokenId: `${n5}-${t12}`, amount: new bignumber_default(e4, 16).toString(10), collection: n5, nonce: t12 };
    } catch (n5) {
    }
  return c5;
}
var c5;
var T6;
var y5 = Dr(() => {
  v();
  Q();
  f14();
  f4();
  c5 = { tokenId: "", amount: "" }, T6 = (r) => r.split("@").map((t12, e4) => [2, 3].includes(e4) ? t12 : m2(t12));
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-DLMGSLQS.js
var import_dist54 = __toESM(require_dist());
function q2({ transaction: e4, address: f26, explorerAddress: n5 }) {
  var i11;
  let v5 = (i11 = e4.tokenIdentifier) != null ? i11 : b2(e4.data).tokenId, o12 = m6(e4), y10 = a9(e4), l19 = d10(f26, e4, o12), I7 = v2(e4), S8 = k4(e4), u21 = g7({ explorerAddress: n5, to: R3.accountDetails(e4.sender) }), L4 = g7({ explorerAddress: n5, to: R3.accountDetails(o12) }), x13 = g7({ explorerAddress: n5, to: R3.senderShard(e4.senderShard) }), D8 = g7({ explorerAddress: n5, to: R3.receiverShard(e4.receiverShard) }), H4 = e4.originalTxHash ? `${e4.originalTxHash}#${e4.txHash}` : e4.txHash, C8 = g7({ explorerAddress: n5, to: R3.transactionDetails(H4) });
  return xt(yt({}, e4), { tokenIdentifier: v5, receiver: o12, receiverAssets: y10, transactionDetails: { direction: l19, method: I7, transactionTokens: S8, isContract: H3(e4.sender) }, links: { senderLink: u21, receiverLink: L4, senderShardLink: x13, receiverShardLink: D8, transactionLink: C8 } });
}
var B = Dr(() => {
  v();
  N6();
  y5();
  i6();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-MCVZ2L7D.js
var import_dist55 = __toESM(require_dist());
var p10 = Dr(() => {
  v();
  B();
  A();
  i6();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-LAFL3AAH.js
var import_dist56 = __toESM(require_dist());
function g11(t12, e4) {
  let n5 = new URLSearchParams(t12), r = Object.fromEntries(n5);
  return { nextUrlParams: new URLSearchParams(yt(yt({}, r), e4)).toString(), params: r };
}
function x7({ callbackUrl: t12, urlParams: e4 = {} }) {
  let n5 = t12;
  if (Object.entries(e4).length > 0)
    try {
      let { search: r, origin: a19, pathname: l19, hash: m12 } = new URL(t12), u21 = xt(yt({}, e4), { [a2]: p11 }), { nextUrlParams: U7 } = g11(r, u21);
      n5 = `${a19}${l19}?${U7}${m12}`;
    } catch (r) {
      return console.error("Unable to construct URL from: ", t12, r), n5;
    }
  return n5;
}
var p11;
var y6 = Dr(() => {
  v();
  T3();
  p11 = "3.1.6";
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-3WKKYGRU.js
var import_dist57 = __toESM(require_dist());
var h6;
var A4;
var l14 = Dr(() => {
  v();
  T3();
  h6 = (r) => {
    let e4 = W.Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    if (r.slice(0, e4.length).equals(e4))
      return true;
    let s6 = W.Buffer.alloc(32).fill(0);
    return r.equals(s6);
  }, A4 = (r) => {
    try {
      let a19 = parseInt("11", 2), s6 = parseInt("01", 2), o12 = W.Buffer.from(r, "hex"), c11 = o12[31];
      if (h6(o12))
        return i2;
      let n5 = c11 & a19;
      return n5 > 3 - 1 && (n5 = c11 & s6), n5;
    } catch (e4) {
      return -1;
    }
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-GNQ52MZT.js
var import_dist58 = __toESM(require_dist());
var import_out = __toESM(require_out());
function T7({ receiverAddress: i11, senderShard: e4, senderAddress: s6 }) {
  try {
    let n5 = new import_out.Address(i11), t12 = A4(n5.pubkey());
    if (e4 == null && s6 != null) {
      let c11 = new import_out.Address(s6);
      return A4(c11) === t12;
    }
    return t12 === e4;
  } catch (n5) {
    return false;
  }
}
var u12 = Dr(() => {
  v();
  l14();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-YOYRVDJG.js
var import_dist59 = __toESM(require_dist());
var y7;
var p12 = Dr(() => {
  v();
  u12();
  N6();
  y7 = (e4, u21 = 1) => e4 != null && e4.length ? e4.reduce((n5, { receiver: m12, data: r }) => {
    let o12 = A3({ receiver: m12, data: r != null ? r : "" });
    return o12 == null ? n5 : n5 && T7({ receiverAddress: o12, senderShard: u21 });
  }, true) : true;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-VSPND6ZN.js
var import_dist60 = __toESM(require_dist());
var import_react = __toESM(require_react());
var h7;
var m8 = Dr(() => {
  v();
  f();
  h7 = ["create", "localMint", "ESDTLocalMint", "addQuantity", "burn", "localBurn", "ESDTLocalBurn", "wipe", "writeLog", "signalError"];
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-NLU2B6MT.js
var import_dist61 = __toESM(require_dist());
var c6;
var l15 = Dr(() => {
  v();
  c6 = (t12, g16 = 4) => `${t12.substring(0, Math.floor(t12.length / g16))}...${t12.substring(t12.length - Math.ceil(t12.length / g16))}`;
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-AQQ7Q6DO.js
var import_dist62 = __toESM(require_dist());
var y8;
var p13 = Dr(() => {
  v();
  f();
  y8 = (r) => {
    var e4, n5;
    switch (r.name) {
      case "transfer":
        return ["Transfer", { token: (e4 = r.arguments) == null ? void 0 : e4.transfers }, "to", { address: (n5 = r.arguments) == null ? void 0 : n5.receiver }];
      default:
        return [];
    }
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-2W6QR4IJ.js
var import_dist63 = __toESM(require_dist());
var C5;
var A5 = Dr(() => {
  v();
  T3();
  f();
  C5 = (e4) => {
    var r, s6, t12, a19, n5, i11, u21, m12, o12, d17, p21, c11;
    switch (e4.name) {
      case "claimLockedAssets":
        return ["Claim locked assets"];
      case "enterFarm":
      case "enterFarmProxy":
        return ["Enter farm with", { token: (r = e4.arguments) == null ? void 0 : r.transfers }];
      case "enterFarmAndLockRewards":
      case "enterFarmAndLockRewardsProxy":
        return ["Enter farm and lock rewards with", { token: (s6 = e4.arguments) == null ? void 0 : s6.transfers }];
      case "exitFarm":
      case "exitFarmProxy":
        return ["Exit farm with", { token: (t12 = e4.arguments) == null ? void 0 : t12.transfers }];
      case "claimRewards":
      case "claimRewardsProxy":
        return ["Claim rewards", { token: (a19 = e4.arguments) == null ? void 0 : a19.transfers }];
      case "compoundRewards":
      case "compoundRewardsProxy":
        return ["Reinvest rewards", { token: (n5 = e4.arguments) == null ? void 0 : n5.transfers }];
      case "swapTokensFixedInput":
      case "swap":
        return e4.description ? [e4.description] : [];
      case "swapTokensFixedOutput":
        return e4.description ? [e4.description] : [];
      case "addLiquidity":
      case "addLiquidityProxy":
        return ["Added liquidity for", { token: [(i11 = e4.arguments) == null ? void 0 : i11.transfers[0]] }, "and", { token: [(u21 = e4.arguments) == null ? void 0 : u21.transfers[1]] }];
      case "removeLiquidity":
      case "removeLiquidityProxy":
        return ["Removed liquidity with ", { token: (m12 = e4.arguments) == null ? void 0 : m12.transfers }];
      case "mergeLockedAssetTokens":
        let f26 = u3;
        if ((o12 = e4.arguments) != null && o12.transfers) {
          let w6 = e4.arguments.transfers.map(({ value: k8 }) => k8);
          f26 = bignumber_default.sum.apply(null, w6).toString(10);
        }
        return [`Merge ${(d17 = e4.arguments) == null ? void 0 : d17.transfers.length}`, { tokenNoLink: [(p21 = e4.arguments) == null ? void 0 : p21.transfers[0]] }, "positions into a single", { tokenNoLink: [(c11 = e4.arguments) == null ? void 0 : c11.transfers[0]] }, "position of value", { value: f26 }];
      case "wrapEgld":
      case "unwrapEgld":
      default:
        return e4.description ? [e4.description] : [];
    }
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-LHJJDJM4.js
var import_dist64 = __toESM(require_dist());
var D5;
var w3 = Dr(() => {
  v();
  f();
  D5 = (r) => {
    var e4, a19, t12, d17, p21, s6, v5, m12, i11, n5, o12, g16;
    switch (r.name) {
      case "delegate":
      case "stake":
        return ["Delegate", { egldValue: (e4 = r.arguments) == null ? void 0 : e4.value }, "to staking provider", { providerName: (a19 = r.arguments) == null ? void 0 : a19.providerName, providerAvatar: (t12 = r.arguments) == null ? void 0 : t12.providerAvatar }];
      case "unDelegate":
        return ["Undelegate", { egldValue: (d17 = r.arguments) == null ? void 0 : d17.value }, "from staking provider", { providerName: (p21 = r.arguments) == null ? void 0 : p21.providerName, providerAvatar: (s6 = r.arguments) == null ? void 0 : s6.providerAvatar }];
      case "claimRewards":
        return ["Claim rewards from staking provider", { providerName: (v5 = r.arguments) == null ? void 0 : v5.providerName, providerAvatar: (m12 = r.arguments) == null ? void 0 : m12.providerAvatar }];
      case "reDelegateRewards":
        return ["Redelegate rewards from staking provider", { providerName: (i11 = r.arguments) == null ? void 0 : i11.providerName, providerAvatar: (n5 = r.arguments) == null ? void 0 : n5.providerAvatar }];
      case "withdraw":
        return ["Withdraw from staking provider", { providerName: (o12 = r.arguments) == null ? void 0 : o12.providerName, providerAvatar: (g16 = r.arguments) == null ? void 0 : g16.providerAvatar }];
      default:
        return [];
    }
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-SSUUG5BL.js
var import_dist65 = __toESM(require_dist());
var k5;
var c7 = Dr(() => {
  v();
  f();
  p13();
  A5();
  w3();
  k5 = (r) => {
    if (!r.arguments)
      return r.description ? [r.description] : [r.name];
    switch (r.category) {
      case "esdtNft":
        return y8(r);
      case "mex":
        return C5(r);
      case "stake":
        return D5(r);
      default:
        return r.description ? [r.description] : [];
    }
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-OY7P7YMY.js
var import_dist66 = __toESM(require_dist());
var f16 = Dr(() => {
  v();
  c7();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-BZYEY4V6.js
var import_dist67 = __toESM(require_dist());
var u13;
var i7 = Dr(() => {
  v();
  u13 = (e4) => {
    let n5 = new bignumber_default(e4.gasPrice), o12 = new bignumber_default(e4.gasUsed);
    return n5.times(o12).toString();
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-KCK6EIJZ.js
var import_dist68 = __toESM(require_dist());
var S3;
var L2 = Dr(() => {
  v();
  u2();
  S3 = ({ transaction: e4, direction: n5 }) => {
    var a19;
    let T9 = n5 === "Internal", r = e4.sender;
    if (T9)
      return { link: (a19 = e4.links.senderLink) != null ? a19 : "", label: "Smart Contract transaction", address: r };
    let i11 = n5 === "Out", t12 = i11 ? e4.links.receiverLink : e4.links.senderLink, s6 = "";
    return n5 === "Self" && e4.receiverAssets ? s6 = e4.receiverAssets.name : (r = i11 ? e4.receiver : e4.sender, s6 = i11 ? "To:" : "From:"), { label: s6, address: r, link: t12 != null ? t12 : "" };
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-POG6DTE2.js
var import_dist69 = __toESM(require_dist());
var p14;
var a12 = Dr(() => {
  v();
  Q();
  p14 = (t12) => {
    switch (true) {
      case t12.pendingResults:
        return "Pending (Smart Contract Execution)";
      case t12.status === "reward-reverted":
        return "fail";
      default:
        return t12.status.toString();
    }
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-XK4XOW72.js
var import_dist70 = __toESM(require_dist());
var n2;
var o10 = Dr(() => {
  v();
  n2 = (a19) => W.Buffer.from(String(a19 == null ? void 0 : a19.data), "base64").toString("hex");
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-KLFPAZSS.js
var import_dist71 = __toESM(require_dist());
var u14;
var p15 = Dr(() => {
  v();
  c();
  u14 = (n5, h12) => {
    var e4;
    let { hash: i11 } = f3(), t12 = i11.split("/"), s6 = t12[0] ? t12[0].replace("#", "") : "", g16 = (e4 = t12[1]) != null ? e4 : 0;
    return s6 === h12 && n5.order === Number(g16);
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-4K4XSAZL.js
var import_dist72 = __toESM(require_dist());
var u15;
var d12 = Dr(() => {
  v();
  f();
  u15 = ({ operation: t12, address: r }) => {
    let i11 = r === t12.sender, n5 = r === t12.receiver, c11 = i11 && n5, a19 = !c11, e4 = "";
    switch (true) {
      case i11:
        e4 = "Out";
        break;
      case n5:
        e4 = "In";
        break;
      case c11:
        e4 = "Self";
        break;
      case a19:
        e4 = "Internal";
        break;
    }
    return { direction: e4 };
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-OF3VHHUR.js
var import_dist73 = __toESM(require_dist());
var d13;
var a13 = Dr(() => {
  v();
  f4();
  d13 = (s6) => {
    let t12 = W.Buffer.from(s6, "base64").toString().split("@");
    return t12.length >= 2 && (t12[0].length > 0 ? t12[0] = m2(t12[0]) : t12[1] = m2(t12[1])), t12.join("@");
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-JW7ZCUB4.js
var import_dist74 = __toESM(require_dist());
var f17;
var s4 = Dr(() => {
  v();
  c();
  f17 = (e4) => {
    let { hash: t12 } = f3();
    return t12.substring(0, t12.indexOf("/") > 0 ? t12.indexOf("/") : t12.length).replace("#", "") === e4;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-F5247DFI.js
var import_dist75 = __toESM(require_dist());
var A6;
var g12 = Dr(() => {
  v();
  T3();
  A6 = (e4) => {
    let t12 = e4;
    typeof t12 == "string" && t12.includes("Shard") && (t12 = t12.replace("Shard", "").replace(" ", ""));
    let S8 = i2.toString() === String(t12).toString() || String(t12) === "metachain", a19 = U2.toString() === String(t12).toString();
    return S8 ? "Metachain" : a19 ? "All Shards" : `Shard ${t12}`;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-4YKO7ZRM.js
var import_dist76 = __toESM(require_dist());
function d14(e4) {
  return Array.from(/* @__PURE__ */ new Set([...p8(e4), ...f13(e4), A2(e4)])).filter((a19) => Boolean(a19));
}
var m9 = Dr(() => {
  v();
  i5();
  l13();
  t7();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-Z6MQL4VU.js
var import_dist77 = __toESM(require_dist());
function m10(e4) {
  let t12 = (i11) => e4.status.toLowerCase() === i11.toLowerCase(), s6 = t12("fail") || t12("reward-reverted"), r = t12("success"), o12 = t12("not executed") || t12("invalid"), a19 = t12("pending") || e4.pendingResults;
  return { failed: s6, success: r, invalid: o12, pending: a19 };
}
var u16 = Dr(() => {
  v();
  Q();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-DBZ3PT4K.js
var import_dist78 = __toESM(require_dist());
var import_react2 = __toESM(require_react());
var S4;
var f18 = Dr(() => {
  v();
  u2();
  c();
  S4 = () => {
    let { hash: r, pathname: o12 } = f3(), t12 = r.replace("#", ""), s6 = t12 && Object.values(o2).includes(t12) ? t12 : "raw", [e4, a19] = (0, import_react2.useState)(t12);
    return (0, import_react2.useEffect)(() => {
      e4 && e4 !== "raw" && (window == null || window.history.replaceState({}, document == null ? void 0 : document.title, `${o12}#${e4}`));
    }, [e4, o12]), { initialDecodeMethod: s6, decodeMethod: e4, setDecodeMethod: a19 };
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-ZRD6IVNQ.js
var import_dist80 = __toESM(require_dist());

// node_modules/linkifyjs/dist/linkify.es.js
var import_dist79 = __toESM(require_dist());
var tlds = "aaa aarp abarth abb abbott abbvie abc able abogado abudhabi ac academy accenture accountant accountants aco actor ad adac ads adult ae aeg aero aetna af afl africa ag agakhan agency ai aig airbus airforce airtel akdn al alfaromeo alibaba alipay allfinanz allstate ally alsace alstom am amazon americanexpress americanfamily amex amfam amica amsterdam analytics android anquan anz ao aol apartments app apple aq aquarelle ar arab aramco archi army arpa art arte as asda asia associates at athleta attorney au auction audi audible audio auspost author auto autos avianca aw aws ax axa az azure ba baby baidu banamex bananarepublic band bank bar barcelona barclaycard barclays barefoot bargains baseball basketball bauhaus bayern bb bbc bbt bbva bcg bcn bd be beats beauty beer bentley berlin best bestbuy bet bf bg bh bharti bi bible bid bike bing bingo bio biz bj black blackfriday blockbuster blog bloomberg blue bm bms bmw bn bnpparibas bo boats boehringer bofa bom bond boo book booking bosch bostik boston bot boutique box br bradesco bridgestone broadway broker brother brussels bs bt bugatti build builders business buy buzz bv bw by bz bzh ca cab cafe cal call calvinklein cam camera camp cancerresearch canon capetown capital capitalone car caravan cards care career careers cars casa case cash casino cat catering catholic cba cbn cbre cbs cc cd center ceo cern cf cfa cfd cg ch chanel channel charity chase chat cheap chintai christmas chrome church ci cipriani circle cisco citadel citi citic city cityeats ck cl claims cleaning click clinic clinique clothing cloud club clubmed cm cn co coach codes coffee college cologne com comcast commbank community company compare computer comsec condos construction consulting contact contractors cooking cookingchannel cool coop corsica country coupon coupons courses cpa cr credit creditcard creditunion cricket crown crs cruise cruises cu cuisinella cv cw cx cy cymru cyou cz dabur dad dance data date dating datsun day dclk dds de deal dealer deals degree delivery dell deloitte delta democrat dental dentist desi design dev dhl diamonds diet digital direct directory discount discover dish diy dj dk dm dnp do docs doctor dog domains dot download drive dtv dubai dunlop dupont durban dvag dvr dz earth eat ec eco edeka edu education ee eg email emerck energy engineer engineering enterprises epson equipment er ericsson erni es esq estate et etisalat eu eurovision eus events exchange expert exposed express extraspace fage fail fairwinds faith family fan fans farm farmers fashion fast fedex feedback ferrari ferrero fi fiat fidelity fido film final finance financial fire firestone firmdale fish fishing fit fitness fj fk flickr flights flir florist flowers fly fm fo foo food foodnetwork football ford forex forsale forum foundation fox fr free fresenius frl frogans frontdoor frontier ftr fujitsu fun fund furniture futbol fyi ga gal gallery gallo gallup game games gap garden gay gb gbiz gd gdn ge gea gent genting george gf gg ggee gh gi gift gifts gives giving gl glass gle global globo gm gmail gmbh gmo gmx gn godaddy gold goldpoint golf goo goodyear goog google gop got gov gp gq gr grainger graphics gratis green gripe grocery group gs gt gu guardian gucci guge guide guitars guru gw gy hair hamburg hangout haus hbo hdfc hdfcbank health healthcare help helsinki here hermes hgtv hiphop hisamitsu hitachi hiv hk hkt hm hn hockey holdings holiday homedepot homegoods homes homesense honda horse hospital host hosting hot hoteles hotels hotmail house how hr hsbc ht hu hughes hyatt hyundai ibm icbc ice icu id ie ieee ifm ikano il im imamat imdb immo immobilien in inc industries infiniti info ing ink institute insurance insure int international intuit investments io ipiranga iq ir irish is ismaili ist istanbul it itau itv jaguar java jcb je jeep jetzt jewelry jio jll jm jmp jnj jo jobs joburg jot joy jp jpmorgan jprs juegos juniper kaufen kddi ke kerryhotels kerrylogistics kerryproperties kfh kg kh ki kia kids kim kinder kindle kitchen kiwi km kn koeln komatsu kosher kp kpmg kpn kr krd kred kuokgroup kw ky kyoto kz la lacaixa lamborghini lamer lancaster lancia land landrover lanxess lasalle lat latino latrobe law lawyer lb lc lds lease leclerc lefrak legal lego lexus lgbt li lidl life lifeinsurance lifestyle lighting like lilly limited limo lincoln linde link lipsy live living lk llc llp loan loans locker locus loft lol london lotte lotto love lpl lplfinancial lr ls lt ltd ltda lu lundbeck luxe luxury lv ly ma macys madrid maif maison makeup man management mango map market marketing markets marriott marshalls maserati mattel mba mc mckinsey md me med media meet melbourne meme memorial men menu merckmsd mg mh miami microsoft mil mini mint mit mitsubishi mk ml mlb mls mm mma mn mo mobi mobile moda moe moi mom monash money monster mormon mortgage moscow moto motorcycles mov movie mp mq mr ms msd mt mtn mtr mu museum music mutual mv mw mx my mz na nab nagoya name natura navy nba nc ne nec net netbank netflix network neustar new news next nextdirect nexus nf nfl ng ngo nhk ni nico nike nikon ninja nissan nissay nl no nokia northwesternmutual norton now nowruz nowtv np nr nra nrw ntt nu nyc nz obi observer office okinawa olayan olayangroup oldnavy ollo om omega one ong onl online ooo open oracle orange org organic origins osaka otsuka ott ovh pa page panasonic paris pars partners parts party passagens pay pccw pe pet pf pfizer pg ph pharmacy phd philips phone photo photography photos physio pics pictet pictures pid pin ping pink pioneer pizza pk pl place play playstation plumbing plus pm pn pnc pohl poker politie porn post pr pramerica praxi press prime pro prod productions prof progressive promo properties property protection pru prudential ps pt pub pw pwc py qa qpon quebec quest racing radio re read realestate realtor realty recipes red redstone redumbrella rehab reise reisen reit reliance ren rent rentals repair report republican rest restaurant review reviews rexroth rich richardli ricoh ril rio rip ro rocher rocks rodeo rogers room rs rsvp ru rugby ruhr run rw rwe ryukyu sa saarland safe safety sakura sale salon samsclub samsung sandvik sandvikcoromant sanofi sap sarl sas save saxo sb sbi sbs sc sca scb schaeffler schmidt scholarships school schule schwarz science scot sd se search seat secure security seek select sener services ses seven sew sex sexy sfr sg sh shangrila sharp shaw shell shia shiksha shoes shop shopping shouji show showtime si silk sina singles site sj sk ski skin sky skype sl sling sm smart smile sn sncf so soccer social softbank software sohu solar solutions song sony soy spa space sport spot sr srl ss st stada staples star statebank statefarm stc stcgroup stockholm storage store stream studio study style su sucks supplies supply support surf surgery suzuki sv swatch swiss sx sy sydney systems sz tab taipei talk taobao target tatamotors tatar tattoo tax taxi tc tci td tdk team tech technology tel temasek tennis teva tf tg th thd theater theatre tiaa tickets tienda tiffany tips tires tirol tj tjmaxx tjx tk tkmaxx tl tm tmall tn to today tokyo tools top toray toshiba total tours town toyota toys tr trade trading training travel travelchannel travelers travelersinsurance trust trv tt tube tui tunes tushu tv tvs tw tz ua ubank ubs ug uk unicom university uno uol ups us uy uz va vacations vana vanguard vc ve vegas ventures verisign vermgensberater vermgensberatung versicherung vet vg vi viajes video vig viking villas vin vip virgin visa vision viva vivo vlaanderen vn vodka volkswagen volvo vote voting voto voyage vu vuelos wales walmart walter wang wanggou watch watches weather weatherchannel webcam weber website wed wedding weibo weir wf whoswho wien wiki williamhill win windows wine winners wme wolterskluwer woodside work works world wow ws wtc wtf xbox xerox xfinity xihuan xin xxx xyz yachts yahoo yamaxun yandex ye yodobashi yoga yokohama you youtube yt yun za zappos zara zero zip zm zone zuerich zw".split(" ");
var utlds = "                                                                                                                                                      ".split(" ");
var assign = function assign2(target, properties) {
  for (var key in properties) {
    target[key] = properties[key];
  }
  return target;
};
var numeric = "numeric";
var ascii = "ascii";
var alpha = "alpha";
var asciinumeric = "asciinumeric";
var alphanumeric = "alphanumeric";
var domain = "domain";
var emoji = "emoji";
var scheme = "scheme";
var slashscheme = "slashscheme";
var whitespace = "whitespace";
function registerGroup(name, groups) {
  if (!(name in groups)) {
    groups[name] = [];
  }
  return groups[name];
}
function addToGroups(t12, flags, groups) {
  if (flags[numeric]) {
    flags[asciinumeric] = true;
    flags[alphanumeric] = true;
  }
  if (flags[ascii]) {
    flags[asciinumeric] = true;
    flags[alpha] = true;
  }
  if (flags[asciinumeric]) {
    flags[alphanumeric] = true;
  }
  if (flags[alpha]) {
    flags[alphanumeric] = true;
  }
  if (flags[alphanumeric]) {
    flags[domain] = true;
  }
  if (flags[emoji]) {
    flags[domain] = true;
  }
  for (var k8 in flags) {
    var group = registerGroup(k8, groups);
    if (group.indexOf(t12) < 0) {
      group.push(t12);
    }
  }
}
function flagsForToken(t12, groups) {
  var result = {};
  for (var c11 in groups) {
    if (groups[c11].indexOf(t12) >= 0) {
      result[c11] = true;
    }
  }
  return result;
}
function State(token) {
  if (token === void 0) {
    token = null;
  }
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token;
}
State.groups = {};
State.prototype = {
  accepts: function accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go: function go(input) {
    var state = this;
    var nextState = state.j[input];
    if (nextState) {
      return nextState;
    }
    for (var i11 = 0; i11 < state.jr.length; i11++) {
      var regex = state.jr[i11][0];
      var _nextState = state.jr[i11][1];
      if (_nextState && regex.test(input)) {
        return _nextState;
      }
    }
    return state.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has: function has(input, exactOnly) {
    if (exactOnly === void 0) {
      exactOnly = false;
    }
    return exactOnly ? input in this.j : !!this.go(input);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta: function ta(inputs, next, flags, groups) {
    for (var i11 = 0; i11 < inputs.length; i11++) {
      this.tt(inputs[i11], next, flags, groups);
    }
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr: function tr(regexp2, next, flags, groups) {
    groups = groups || State.groups;
    var nextState;
    if (next && next.j) {
      nextState = next;
    } else {
      nextState = new State(next);
      if (flags && groups) {
        addToGroups(next, flags, groups);
      }
    }
    this.jr.push([regexp2, nextState]);
    return nextState;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts: function ts(input, next, flags, groups) {
    var state = this;
    var len = input.length;
    if (!len) {
      return state;
    }
    for (var i11 = 0; i11 < len - 1; i11++) {
      state = state.tt(input[i11]);
    }
    return state.tt(input[len - 1], next, flags, groups);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt: function tt(input, next, flags, groups) {
    groups = groups || State.groups;
    var state = this;
    if (next && next.j) {
      state.j[input] = next;
      return next;
    }
    var t12 = next;
    var nextState, templateState = state.go(input);
    if (templateState) {
      nextState = new State();
      assign(nextState.j, templateState.j);
      nextState.jr.push.apply(nextState.jr, templateState.jr);
      nextState.jd = templateState.jd;
      nextState.t = templateState.t;
    } else {
      nextState = new State();
    }
    if (t12) {
      if (groups) {
        if (nextState.t && typeof nextState.t === "string") {
          var allFlags = assign(flagsForToken(nextState.t, groups), flags);
          addToGroups(t12, allFlags, groups);
        } else if (flags) {
          addToGroups(t12, flags, groups);
        }
      }
      nextState.t = t12;
    }
    state.j[input] = nextState;
    return nextState;
  }
};
var ta2 = function ta3(state, input, next, flags, groups) {
  return state.ta(input, next, flags, groups);
};
var tr2 = function tr3(state, regexp2, next, flags, groups) {
  return state.tr(regexp2, next, flags, groups);
};
var ts2 = function ts3(state, input, next, flags, groups) {
  return state.ts(input, next, flags, groups);
};
var tt2 = function tt3(state, input, next, flags, groups) {
  return state.tt(input, next, flags, groups);
};
var WORD = "WORD";
var UWORD = "UWORD";
var LOCALHOST = "LOCALHOST";
var TLD = "TLD";
var UTLD = "UTLD";
var SCHEME = "SCHEME";
var SLASH_SCHEME = "SLASH_SCHEME";
var NUM = "NUM";
var WS = "WS";
var NL$1 = "NL";
var OPENBRACE = "OPENBRACE";
var OPENBRACKET = "OPENBRACKET";
var OPENANGLEBRACKET = "OPENANGLEBRACKET";
var OPENPAREN = "OPENPAREN";
var CLOSEBRACE = "CLOSEBRACE";
var CLOSEBRACKET = "CLOSEBRACKET";
var CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
var CLOSEPAREN = "CLOSEPAREN";
var AMPERSAND = "AMPERSAND";
var APOSTROPHE = "APOSTROPHE";
var ASTERISK = "ASTERISK";
var AT = "AT";
var BACKSLASH = "BACKSLASH";
var BACKTICK = "BACKTICK";
var CARET = "CARET";
var COLON = "COLON";
var COMMA = "COMMA";
var DOLLAR = "DOLLAR";
var DOT = "DOT";
var EQUALS = "EQUALS";
var EXCLAMATION = "EXCLAMATION";
var HYPHEN = "HYPHEN";
var PERCENT = "PERCENT";
var PIPE = "PIPE";
var PLUS = "PLUS";
var POUND = "POUND";
var QUERY = "QUERY";
var QUOTE = "QUOTE";
var SEMI = "SEMI";
var SLASH = "SLASH";
var TILDE = "TILDE";
var UNDERSCORE = "UNDERSCORE";
var EMOJI$1 = "EMOJI";
var SYM = "SYM";
var tk = Object.freeze({
  __proto__: null,
  WORD,
  UWORD,
  LOCALHOST,
  TLD,
  UTLD,
  SCHEME,
  SLASH_SCHEME,
  NUM,
  WS,
  NL: NL$1,
  OPENBRACE,
  OPENBRACKET,
  OPENANGLEBRACKET,
  OPENPAREN,
  CLOSEBRACE,
  CLOSEBRACKET,
  CLOSEANGLEBRACKET,
  CLOSEPAREN,
  AMPERSAND,
  APOSTROPHE,
  ASTERISK,
  AT,
  BACKSLASH,
  BACKTICK,
  CARET,
  COLON,
  COMMA,
  DOLLAR,
  DOT,
  EQUALS,
  EXCLAMATION,
  HYPHEN,
  PERCENT,
  PIPE,
  PLUS,
  POUND,
  QUERY,
  QUOTE,
  SEMI,
  SLASH,
  TILDE,
  UNDERSCORE,
  EMOJI: EMOJI$1,
  SYM
});
var ASCII_LETTER = /[a-z]/;
var LETTER = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/;
var EMOJI = /(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDD-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6])/;
var EMOJI_VARIATION$1 = /\ufe0f/;
var DIGIT = /\d/;
var SPACE = /\s/;
var regexp = Object.freeze({
  __proto__: null,
  ASCII_LETTER,
  LETTER,
  EMOJI,
  EMOJI_VARIATION: EMOJI_VARIATION$1,
  DIGIT,
  SPACE
});
var NL = "\n";
var EMOJI_VARIATION = "";
var EMOJI_JOINER = "";
function init$2(customSchemes) {
  var _tr, _tr2, _tr3, _tr4, _tt, _tr5;
  if (customSchemes === void 0) {
    customSchemes = [];
  }
  var groups = {};
  State.groups = groups;
  var Start = new State();
  tt2(Start, "'", APOSTROPHE);
  tt2(Start, "{", OPENBRACE);
  tt2(Start, "[", OPENBRACKET);
  tt2(Start, "<", OPENANGLEBRACKET);
  tt2(Start, "(", OPENPAREN);
  tt2(Start, "}", CLOSEBRACE);
  tt2(Start, "]", CLOSEBRACKET);
  tt2(Start, ">", CLOSEANGLEBRACKET);
  tt2(Start, ")", CLOSEPAREN);
  tt2(Start, "&", AMPERSAND);
  tt2(Start, "*", ASTERISK);
  tt2(Start, "@", AT);
  tt2(Start, "`", BACKTICK);
  tt2(Start, "^", CARET);
  tt2(Start, ":", COLON);
  tt2(Start, ",", COMMA);
  tt2(Start, "$", DOLLAR);
  tt2(Start, ".", DOT);
  tt2(Start, "=", EQUALS);
  tt2(Start, "!", EXCLAMATION);
  tt2(Start, "-", HYPHEN);
  tt2(Start, "%", PERCENT);
  tt2(Start, "|", PIPE);
  tt2(Start, "+", PLUS);
  tt2(Start, "#", POUND);
  tt2(Start, "?", QUERY);
  tt2(Start, '"', QUOTE);
  tt2(Start, "/", SLASH);
  tt2(Start, ";", SEMI);
  tt2(Start, "~", TILDE);
  tt2(Start, "_", UNDERSCORE);
  tt2(Start, "\\", BACKSLASH);
  var Num = tr2(Start, DIGIT, NUM, (_tr = {}, _tr[numeric] = true, _tr));
  tr2(Num, DIGIT, Num);
  var Word = tr2(Start, ASCII_LETTER, WORD, (_tr2 = {}, _tr2[ascii] = true, _tr2));
  tr2(Word, ASCII_LETTER, Word);
  var UWord = tr2(Start, LETTER, UWORD, (_tr3 = {}, _tr3[alpha] = true, _tr3));
  tr2(UWord, ASCII_LETTER);
  tr2(UWord, LETTER, UWord);
  var Ws = tr2(Start, SPACE, WS, (_tr4 = {}, _tr4[whitespace] = true, _tr4));
  tt2(Start, NL, NL$1, (_tt = {}, _tt[whitespace] = true, _tt));
  tt2(Ws, NL);
  tr2(Ws, SPACE, Ws);
  var Emoji = tr2(Start, EMOJI, EMOJI$1, (_tr5 = {}, _tr5[emoji] = true, _tr5));
  tr2(Emoji, EMOJI, Emoji);
  tt2(Emoji, EMOJI_VARIATION, Emoji);
  var EmojiJoiner = tt2(Emoji, EMOJI_JOINER);
  tr2(EmojiJoiner, EMOJI, Emoji);
  var wordjr = [[ASCII_LETTER, Word]];
  var uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];
  for (var i11 = 0; i11 < tlds.length; i11++) {
    fastts(Start, tlds[i11], TLD, WORD, wordjr);
  }
  for (var _i = 0; _i < utlds.length; _i++) {
    fastts(Start, utlds[_i], UTLD, UWORD, uwordjr);
  }
  addToGroups(TLD, {
    tld: true,
    ascii: true
  }, groups);
  addToGroups(UTLD, {
    utld: true,
    alpha: true
  }, groups);
  fastts(Start, "file", SCHEME, WORD, wordjr);
  fastts(Start, "mailto", SCHEME, WORD, wordjr);
  fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
  addToGroups(SCHEME, {
    scheme: true,
    ascii: true
  }, groups);
  addToGroups(SLASH_SCHEME, {
    slashscheme: true,
    ascii: true
  }, groups);
  customSchemes = customSchemes.sort(function(a19, b3) {
    return a19[0] > b3[0] ? 1 : -1;
  });
  for (var _i2 = 0; _i2 < customSchemes.length; _i2++) {
    var _ref, _ref2;
    var sch = customSchemes[_i2][0];
    var optionalSlashSlash = customSchemes[_i2][1];
    var flags = optionalSlashSlash ? (_ref = {}, _ref[scheme] = true, _ref) : (_ref2 = {}, _ref2[slashscheme] = true, _ref2);
    if (sch.indexOf("-") >= 0) {
      flags[domain] = true;
    } else if (!ASCII_LETTER.test(sch)) {
      flags[numeric] = true;
    } else if (DIGIT.test(sch)) {
      flags[asciinumeric] = true;
    } else {
      flags[ascii] = true;
    }
    ts2(Start, sch, sch, flags);
  }
  ts2(Start, "localhost", LOCALHOST, {
    ascii: true
  });
  Start.jd = new State(SYM);
  return {
    start: Start,
    tokens: assign({
      groups
    }, tk)
  };
}
function run$1(start, str) {
  var iterable = stringToArray(str.replace(/[A-Z]/g, function(c11) {
    return c11.toLowerCase();
  }));
  var charCount = iterable.length;
  var tokens = [];
  var cursor = 0;
  var charCursor = 0;
  while (charCursor < charCount) {
    var state = start;
    var nextState = null;
    var tokenLength = 0;
    var latestAccepting = null;
    var sinceAccepts = -1;
    var charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      // token type/name
      v: str.slice(cursor - tokenLength, cursor),
      // string value
      s: cursor - tokenLength,
      // start index
      e: cursor
      // end index (excluding)
    });
  }
  return tokens;
}
function stringToArray(str) {
  var result = [];
  var len = str.length;
  var index = 0;
  while (index < len) {
    var first = str.charCodeAt(index);
    var second = void 0;
    var char = first < 55296 || first > 56319 || index + 1 === len || (second = str.charCodeAt(index + 1)) < 56320 || second > 57343 ? str[index] : str.slice(index, index + 2);
    result.push(char);
    index += char.length;
  }
  return result;
}
function fastts(state, input, t12, defaultt, jr) {
  var next;
  var len = input.length;
  for (var i11 = 0; i11 < len - 1; i11++) {
    var char = input[i11];
    if (state.j[char]) {
      next = state.j[char];
    } else {
      next = new State(defaultt);
      next.jr = jr.slice();
      state.j[char] = next;
    }
    state = next;
  }
  next = new State(t12);
  next.jr = jr.slice();
  state.j[input[len - 1]] = next;
  return next;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o12, p21) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o13, p22) {
    o13.__proto__ = p22;
    return o13;
  };
  return _setPrototypeOf(o12, p21);
}
var defaults = {
  defaultProtocol: "http",
  events: null,
  format: noop,
  formatHref: noop,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: Infinity,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Options(opts, defaultRender2) {
  if (defaultRender2 === void 0) {
    defaultRender2 = null;
  }
  var o12 = assign({}, defaults);
  if (opts) {
    o12 = assign(o12, opts instanceof Options ? opts.o : opts);
  }
  var ignoredTags = o12.ignoreTags;
  var uppercaseIgnoredTags = [];
  for (var i11 = 0; i11 < ignoredTags.length; i11++) {
    uppercaseIgnoredTags.push(ignoredTags[i11].toUpperCase());
  }
  this.o = o12;
  if (defaultRender2) {
    this.defaultRender = defaultRender2;
  }
  this.ignoreTags = uppercaseIgnoredTags;
}
Options.prototype = {
  o: defaults,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender: function defaultRender(ir) {
    return ir;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check: function check(token) {
    return this.get("validate", token.toString(), token);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get: function get(key, operator, token) {
    var isCallable = operator != null;
    var option = this.o[key];
    if (!option) {
      return option;
    }
    if (typeof option === "object") {
      option = token.t in option ? option[token.t] : defaults[key];
      if (typeof option === "function" && isCallable) {
        option = option(operator, token);
      }
    } else if (typeof option === "function" && isCallable) {
      option = option(operator, token.t, token);
    }
    return option;
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj: function getObj(key, operator, token) {
    var obj = this.o[key];
    if (typeof obj === "function" && operator != null) {
      obj = obj(operator, token.t, token);
    }
    return obj;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render: function render(token) {
    var ir = token.render(this);
    var renderFn = this.get("render", null, token) || this.defaultRender;
    return renderFn(ir, token.t, token);
  }
};
function noop(val) {
  return val;
}
var options = Object.freeze({
  __proto__: null,
  defaults,
  Options,
  assign
});
function MultiToken(value, tokens) {
  this.t = "token";
  this.v = value;
  this.tk = tokens;
}
MultiToken.prototype = {
  isLink: false,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString: function toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
  */
  toHref: function toHref(scheme2) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString: function toFormattedString(options2) {
    var val = this.toString();
    var truncate = options2.get("truncate", val, this);
    var formatted = options2.get("format", val, this);
    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "" : formatted;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref: function toFormattedHref(options2) {
    return options2.get("formatHref", this.toHref(options2.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex: function startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex: function endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject: function toObject(protocol) {
    if (protocol === void 0) {
      protocol = defaults.defaultProtocol;
    }
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject: function toFormattedObject(options2) {
    return {
      type: this.t,
      value: this.toFormattedString(options2),
      isLink: this.isLink,
      href: this.toFormattedHref(options2),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate: function validate(options2) {
    return options2.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render: function render2(options2) {
    var token = this;
    var href = this.toFormattedHref(options2);
    var tagName = options2.get("tagName", href, token);
    var content = this.toFormattedString(options2);
    var attributes = {};
    var className = options2.get("className", href, token);
    var target = options2.get("target", href, token);
    var rel = options2.get("rel", href, token);
    var attrs = options2.getObj("attributes", href, token);
    var eventListeners = options2.getObj("events", href, token);
    attributes.href = href;
    if (className) {
      attributes.class = className;
    }
    if (target) {
      attributes.target = target;
    }
    if (rel) {
      attributes.rel = rel;
    }
    if (attrs) {
      assign(attributes, attrs);
    }
    return {
      tagName,
      attributes,
      content,
      eventListeners
    };
  }
};
function createTokenClass(type, props) {
  var Token = function(_MultiToken) {
    _inheritsLoose(Token2, _MultiToken);
    function Token2(value, tokens) {
      var _this;
      _this = _MultiToken.call(this, value, tokens) || this;
      _this.t = type;
      return _this;
    }
    return Token2;
  }(MultiToken);
  for (var p21 in props) {
    Token.prototype[p21] = props[p21];
  }
  Token.t = type;
  return Token;
}
var Email = createTokenClass("email", {
  isLink: true,
  toHref: function toHref2() {
    return "mailto:" + this.toString();
  }
});
var Text = createTokenClass("text");
var Nl = createTokenClass("nl");
var Url = createTokenClass("url", {
  isLink: true,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref: function toHref3(scheme2) {
    if (scheme2 === void 0) {
      scheme2 = defaults.defaultProtocol;
    }
    return this.hasProtocol() ? this.v : scheme2 + "://" + this.v;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol: function hasProtocol() {
    var tokens = this.tk;
    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
  }
});
var multi = Object.freeze({
  __proto__: null,
  MultiToken,
  Base: MultiToken,
  createTokenClass,
  Email,
  Text,
  Nl,
  Url
});
var makeState = function makeState2(arg) {
  return new State(arg);
};
function init$1(_ref) {
  var groups = _ref.groups;
  var qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
  var qsNonAccepting = [APOSTROPHE, CLOSEANGLEBRACKET, CLOSEBRACE, CLOSEBRACKET, CLOSEPAREN, COLON, COMMA, DOT, EXCLAMATION, OPENANGLEBRACKET, OPENBRACE, OPENBRACKET, OPENPAREN, QUERY, QUOTE, SEMI];
  var localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, CLOSEBRACE, DOLLAR, EQUALS, HYPHEN, NUM, OPENBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
  var Start = makeState();
  var Localpart = tt2(Start, TILDE);
  ta2(Localpart, localpartAccepting, Localpart);
  ta2(Localpart, groups.domain, Localpart);
  var Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
  ta2(Start, groups.domain, Domain);
  ta2(Start, groups.scheme, Scheme);
  ta2(Start, groups.slashscheme, SlashScheme);
  ta2(Domain, localpartAccepting, Localpart);
  ta2(Domain, groups.domain, Domain);
  var LocalpartAt = tt2(Domain, AT);
  tt2(Localpart, AT, LocalpartAt);
  var LocalpartDot = tt2(Localpart, DOT);
  ta2(LocalpartDot, localpartAccepting, Localpart);
  ta2(LocalpartDot, groups.domain, Localpart);
  var EmailDomain = makeState();
  ta2(LocalpartAt, groups.domain, EmailDomain);
  ta2(EmailDomain, groups.domain, EmailDomain);
  var EmailDomainDot = tt2(EmailDomain, DOT);
  ta2(EmailDomainDot, groups.domain, EmailDomain);
  var Email$1 = makeState(Email);
  ta2(EmailDomainDot, groups.tld, Email$1);
  ta2(EmailDomainDot, groups.utld, Email$1);
  tt2(LocalpartAt, LOCALHOST, Email$1);
  var EmailDomainHyphen = tt2(EmailDomain, HYPHEN);
  ta2(EmailDomainHyphen, groups.domain, EmailDomain);
  ta2(Email$1, groups.domain, EmailDomain);
  tt2(Email$1, DOT, EmailDomainDot);
  tt2(Email$1, HYPHEN, EmailDomainHyphen);
  var EmailColon = tt2(Email$1, COLON);
  ta2(EmailColon, groups.numeric, Email);
  var DomainHyphen = tt2(Domain, HYPHEN);
  var DomainDot = tt2(Domain, DOT);
  ta2(DomainHyphen, groups.domain, Domain);
  ta2(DomainDot, localpartAccepting, Localpart);
  ta2(DomainDot, groups.domain, Domain);
  var DomainDotTld = makeState(Url);
  ta2(DomainDot, groups.tld, DomainDotTld);
  ta2(DomainDot, groups.utld, DomainDotTld);
  ta2(DomainDotTld, groups.domain, Domain);
  ta2(DomainDotTld, localpartAccepting, Localpart);
  tt2(DomainDotTld, DOT, DomainDot);
  tt2(DomainDotTld, HYPHEN, DomainHyphen);
  tt2(DomainDotTld, AT, LocalpartAt);
  var DomainDotTldColon = tt2(DomainDotTld, COLON);
  var DomainDotTldColonPort = makeState(Url);
  ta2(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
  var Url$1 = makeState(Url);
  var UrlNonaccept = makeState();
  ta2(Url$1, qsAccepting, Url$1);
  ta2(Url$1, qsNonAccepting, UrlNonaccept);
  ta2(UrlNonaccept, qsAccepting, Url$1);
  ta2(UrlNonaccept, qsNonAccepting, UrlNonaccept);
  tt2(DomainDotTld, SLASH, Url$1);
  tt2(DomainDotTldColonPort, SLASH, Url$1);
  var UriPrefix = tt2(Scheme, COLON);
  var SlashSchemeColon = tt2(SlashScheme, COLON);
  var SlashSchemeColonSlash = tt2(SlashSchemeColon, SLASH);
  tt2(SlashSchemeColonSlash, SLASH, UriPrefix);
  ta2(Scheme, groups.domain, Domain);
  tt2(Scheme, DOT, DomainDot);
  tt2(Scheme, HYPHEN, DomainHyphen);
  ta2(SlashScheme, groups.domain, Domain);
  tt2(SlashScheme, DOT, DomainDot);
  tt2(SlashScheme, HYPHEN, DomainHyphen);
  ta2(UriPrefix, groups.domain, Url$1);
  tt2(UriPrefix, SLASH, Url$1);
  var UrlOpenbrace = tt2(Url$1, OPENBRACE);
  var UrlOpenbracket = tt2(Url$1, OPENBRACKET);
  var UrlOpenanglebracket = tt2(Url$1, OPENANGLEBRACKET);
  var UrlOpenparen = tt2(Url$1, OPENPAREN);
  tt2(UrlNonaccept, OPENBRACE, UrlOpenbrace);
  tt2(UrlNonaccept, OPENBRACKET, UrlOpenbracket);
  tt2(UrlNonaccept, OPENANGLEBRACKET, UrlOpenanglebracket);
  tt2(UrlNonaccept, OPENPAREN, UrlOpenparen);
  tt2(UrlOpenbrace, CLOSEBRACE, Url$1);
  tt2(UrlOpenbracket, CLOSEBRACKET, Url$1);
  tt2(UrlOpenanglebracket, CLOSEANGLEBRACKET, Url$1);
  tt2(UrlOpenparen, CLOSEPAREN, Url$1);
  tt2(UrlOpenbrace, CLOSEBRACE, Url$1);
  var UrlOpenbraceQ = makeState(Url);
  var UrlOpenbracketQ = makeState(Url);
  var UrlOpenanglebracketQ = makeState(Url);
  var UrlOpenparenQ = makeState(Url);
  ta2(UrlOpenbrace, qsAccepting, UrlOpenbraceQ);
  ta2(UrlOpenbracket, qsAccepting, UrlOpenbracketQ);
  ta2(UrlOpenanglebracket, qsAccepting, UrlOpenanglebracketQ);
  ta2(UrlOpenparen, qsAccepting, UrlOpenparenQ);
  var UrlOpenbraceSyms = makeState();
  var UrlOpenbracketSyms = makeState();
  var UrlOpenanglebracketSyms = makeState();
  var UrlOpenparenSyms = makeState();
  ta2(UrlOpenbrace, qsNonAccepting);
  ta2(UrlOpenbracket, qsNonAccepting);
  ta2(UrlOpenanglebracket, qsNonAccepting);
  ta2(UrlOpenparen, qsNonAccepting);
  ta2(UrlOpenbraceQ, qsAccepting, UrlOpenbraceQ);
  ta2(UrlOpenbracketQ, qsAccepting, UrlOpenbracketQ);
  ta2(UrlOpenanglebracketQ, qsAccepting, UrlOpenanglebracketQ);
  ta2(UrlOpenparenQ, qsAccepting, UrlOpenparenQ);
  ta2(UrlOpenbraceQ, qsNonAccepting, UrlOpenbraceQ);
  ta2(UrlOpenbracketQ, qsNonAccepting, UrlOpenbracketQ);
  ta2(UrlOpenanglebracketQ, qsNonAccepting, UrlOpenanglebracketQ);
  ta2(UrlOpenparenQ, qsNonAccepting, UrlOpenparenQ);
  ta2(UrlOpenbraceSyms, qsAccepting, UrlOpenbraceSyms);
  ta2(UrlOpenbracketSyms, qsAccepting, UrlOpenbracketQ);
  ta2(UrlOpenanglebracketSyms, qsAccepting, UrlOpenanglebracketQ);
  ta2(UrlOpenparenSyms, qsAccepting, UrlOpenparenQ);
  ta2(UrlOpenbraceSyms, qsNonAccepting, UrlOpenbraceSyms);
  ta2(UrlOpenbracketSyms, qsNonAccepting, UrlOpenbracketSyms);
  ta2(UrlOpenanglebracketSyms, qsNonAccepting, UrlOpenanglebracketSyms);
  ta2(UrlOpenparenSyms, qsNonAccepting, UrlOpenparenSyms);
  tt2(UrlOpenbracketQ, CLOSEBRACKET, Url$1);
  tt2(UrlOpenanglebracketQ, CLOSEANGLEBRACKET, Url$1);
  tt2(UrlOpenparenQ, CLOSEPAREN, Url$1);
  tt2(UrlOpenbraceQ, CLOSEBRACE, Url$1);
  tt2(UrlOpenbracketSyms, CLOSEBRACKET, Url$1);
  tt2(UrlOpenanglebracketSyms, CLOSEANGLEBRACKET, Url$1);
  tt2(UrlOpenparenSyms, CLOSEPAREN, Url$1);
  tt2(UrlOpenbraceSyms, CLOSEPAREN, Url$1);
  tt2(Start, LOCALHOST, DomainDotTld);
  tt2(Start, NL$1, Nl);
  return {
    start: Start,
    tokens: tk
  };
}
function run(start, input, tokens) {
  var len = tokens.length;
  var cursor = 0;
  var multis = [];
  var textTokens = [];
  while (cursor < len) {
    var state = start;
    var secondState = null;
    var nextState = null;
    var multiLength = 0;
    var latestAccepting = null;
    var sinceAccepts = -1;
    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      cursor -= multiLength;
      if (cursor < len) {
        textTokens.push(tokens[cursor]);
        cursor++;
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(initMultiToken(Text, input, textTokens));
        textTokens = [];
      }
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;
      var Multi = latestAccepting.t;
      var subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(initMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(initMultiToken(Text, input, textTokens));
  }
  return multis;
}
function initMultiToken(Multi, input, tokens) {
  var startIdx = tokens[0].s;
  var endIdx = tokens[tokens.length - 1].e;
  var value = input.slice(startIdx, endIdx);
  return new Multi(value, tokens);
}
var INIT = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: false
};
function init() {
  INIT.scanner = init$2(INIT.customSchemes);
  for (var i11 = 0; i11 < INIT.tokenQueue.length; i11++) {
    INIT.tokenQueue[i11][1]({
      scanner: INIT.scanner
    });
  }
  INIT.parser = init$1(INIT.scanner.tokens);
  for (var _i = 0; _i < INIT.pluginQueue.length; _i++) {
    INIT.pluginQueue[_i][1]({
      scanner: INIT.scanner,
      parser: INIT.parser
    });
  }
  INIT.initialized = true;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init();
  }
  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));
}
function find(str, type, opts) {
  if (type === void 0) {
    type = null;
  }
  if (opts === void 0) {
    opts = null;
  }
  if (type && typeof type === "object") {
    if (opts) {
      throw Error("linkifyjs: Invalid link type " + type + "; must be a string");
    }
    opts = type;
    type = null;
  }
  var options2 = new Options(opts);
  var tokens = tokenize(str);
  var filtered = [];
  for (var i11 = 0; i11 < tokens.length; i11++) {
    var token = tokens[i11];
    if (token.isLink && (!type || token.t === type)) {
      filtered.push(token.toFormattedObject(options2));
    }
  }
  return filtered;
}

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-ZRD6IVNQ.js
var a14;
var T8;
var h8 = Dr(() => {
  v();
  a14 = (s6) => {
    let i11 = find(s6);
    if (!i11.length)
      return { textWithLinks: s6, hasLinks: false };
    let e4 = s6;
    for (let t12 of i11) {
      let n5 = s6.substring(t12.start, t12.end);
      e4 = e4.replace(n5, t12.value);
    }
    return { textWithLinks: e4, hasLinks: true };
  }, T8 = ({ message: s6, scamInfo: i11, isNsfw: e4, verified: t12, messagePrefix: n5 = "Message hidden due to suspicious content - " }) => {
    var o12;
    if (t12)
      return { message: "", textWithLinks: "", isSuspicious: false };
    let k8 = `${n5}${(o12 = i11 == null ? void 0 : i11.info) != null ? o12 : "suspicious content"}`, { textWithLinks: u21, hasLinks: c11 } = a14(s6);
    return c11 || e4 || i11 ? { message: k8, textWithLinks: u21, isSuspicious: true } : { message: "", textWithLinks: u21, isSuspicious: false };
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-BI7MFSOQ.js
var import_dist81 = __toESM(require_dist());
var a15;
var i8;
var h9;
var o11 = Dr(() => {
  v();
  a15 = (n5) => n5.toLowerCase().match(/^[0-9a-f]+$/i), i8 = (n5) => n5.length % 2 === 0, h9 = (n5) => {
    let e4 = [];
    return n5 && !a15(n5) && e4.push(`Invalid Hex characters on argument @${n5}`), n5 && !i8(n5) && e4.push(`Odd number of Hex characters on argument @${n5}`), e4;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-4GKSQE2H.js
var import_dist82 = __toESM(require_dist());
var import_out2 = __toESM(require_out());
var A7;
var x8 = Dr(() => {
  v();
  f();
  f14();
  x3();
  A7 = (e4, m12, r) => {
    switch (m12) {
      case "text":
        try {
          return W.Buffer.from(e4, "hex").toString("utf8");
        } catch (t12) {
        }
        return e4;
      case "decimal":
        return e4 !== "" ? new bignumber_default(e4, 16).toString(10) : "";
      case "smart":
        try {
          let t12 = import_out2.Address.fromHex(e4).toString();
          if (g9(t12))
            return t12;
        } catch (t12) {
        }
        try {
          let t12 = W.Buffer.from(e4, "hex").toString("utf8");
          if (l4(t12))
            return t12;
          {
            if (r && [...r.esdts, ...r.nfts].some((f26) => t12.includes(f26)))
              return t12;
            let n5 = new bignumber_default(e4, 16);
            return n5.isFinite() ? n5.toString(10) : e4;
          }
        } catch (t12) {
        }
        return e4;
      case "raw":
      default:
        return e4;
    }
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-4DAANLRO.js
var import_dist83 = __toESM(require_dist());
var p17;
var f19 = Dr(() => {
  v();
  u2();
  x8();
  p17 = ({ parts: e4, decodedParts: n5, identifier: i11 }) => {
    let r = [...n5];
    if (e4[0] === "ESDTNFTTransfer" && e4[2] && (r[2] = A7(e4[2], "decimal")), i11 === "ESDTNFTTransfer" && e4[1]) {
      let a19 = W.Buffer.from(String(e4[1]), "base64");
      r[1] = A7(a19.toString("hex"), "decimal");
    }
    return r;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-MVXGMWHA.js
var import_dist84 = __toESM(require_dist());
var M3;
var u18 = Dr(() => {
  v();
  u2();
  x8();
  o11();
  f19();
  M3 = ({ parts: t12, decodeMethod: n5, identifier: g16, display: d17 }) => {
    let r = t12.map((e4, a19) => {
      if (t12.length >= 2 && (a19 === 0 && e4.length < 64 || a19 === 1 && !t12[0]))
        return /[^a-z0-9]/gi.test(e4) ? A7(e4, n5) : e4;
      {
        let o12 = h9(e4);
        return o12.length && (d17.validationWarnings = Array.from(/* @__PURE__ */ new Set([...d17.validationWarnings, ...o12]))), A7(e4, n5);
      }
    });
    return n5 === "smart" ? p17({ parts: t12, decodedParts: r, identifier: g16 }) : r;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-3G2HCPRQ.js
var import_dist85 = __toESM(require_dist());
var t8 = Dr(() => {
  v();
  x8();
  u18();
  o11();
  f19();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-6P2POR4F.js
var import_dist86 = __toESM(require_dist());
var B2;
var P2 = Dr(() => {
  v();
  f();
  t8();
  B2 = ({ input: s6, decodeMethod: a19, identifier: d17 }) => {
    let e4 = { displayValue: "", validationWarnings: [] };
    if (!s6.includes("@") && !s6.includes(`
`))
      return e4.displayValue = A7(s6, a19), e4;
    if (s6.includes("@")) {
      let r = s6.split("@"), o12 = M3({ parts: r, identifier: d17, decodeMethod: a19, display: e4 });
      e4.displayValue = o12.join("@");
    }
    if (s6.includes(`
`)) {
      let r = s6.split(`
`), o12 = r.map((l19) => {
        let D8 = W.Buffer.from(l19, "base64");
        return a19 === "raw" ? l19 : A7(D8.toString("hex"), a19);
      }), y10 = a19 === "smart" ? p17({ parts: r, decodedParts: o12, identifier: d17 }) : o12;
      e4.displayValue = y10.join(`
`);
    }
    return e4;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-KN6D65Z4.js
var import_dist87 = __toESM(require_dist());
var f20 = Dr(() => {
  v();
  P2();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-NUDS6AEB.js
var import_dist88 = __toESM(require_dist());
var import_react3 = __toESM(require_react());
var f21;
var M4;
var g13 = Dr(() => {
  v();
  u2();
  f20();
  f21 = [{ label: "Raw", value: "raw" }, { label: "Text", value: "text" }, { label: "Decimal", value: "decimal" }, { label: "Smart", value: "smart" }], M4 = ({ value: c11, initialDecodeMethod: e4, setDecodeMethod: a19, identifier: r }) => {
    let [t12, n5] = (0, import_react3.useState)(e4 && Object.values(o2).includes(e4) ? e4 : "raw"), { displayValue: l19, validationWarnings: d17 } = B2({ input: c11, decodeMethod: t12, identifier: r });
    return (0, import_react3.useEffect)(() => {
      a19 && a19(t12);
    }, [t12]), { displayValue: l19, validationWarnings: d17, setActiveKey: n5, decodeOptions: f21 };
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-CCK4MBG6.js
var import_dist89 = __toESM(require_dist());
var v4 = Dr(() => {
  v();
  o10();
  p15();
  d12();
  a13();
  s4();
  h8();
  g12();
  d8();
  d9();
  i7();
  L2();
  m9();
  u16();
  a12();
  l15();
  T4();
  f16();
  g13();
  f18();
  m8();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-AAI7OAOT.js
var import_dist90 = __toESM(require_dist());
var x9;
var l17 = Dr(() => {
  v();
  x9 = ({ data: n5, highlight: t12, occurrences: s6, transactionIndex: r }) => {
    let e4 = s6[r] || n5.indexOf(t12), c11 = t12.length, g16 = n5.slice(0, e4), h12 = n5.slice(e4 + c11);
    return { start: g16, end: h12 };
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-276YS6GD.js
var import_dist91 = __toESM(require_dist());
var c8;
var p18;
var d15;
var u19 = Dr(() => {
  v();
  c2();
  g3();
  c8 = { errorMessage: l2, successMessage: u4, processingMessage: p }, p18 = (e4) => e4.transactionsInfo, d15 = u5(p18, (e4, o12) => o12, (e4, o12) => o12 != null && (e4 == null ? void 0 : e4[Number(o12)]) || c8);
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-H6BZGL2Y.js
var import_dist92 = __toESM(require_dist());
var i9;
var S5;
var a16 = Dr(() => {
  v();
  c2();
  i9 = (e4) => e4.dappConfig, S5 = u5(i9, (e4) => e4.shouldUseWebViewProvider);
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-3MPYMFCZ.js
var import_dist93 = __toESM(require_dist());
var t9;
var A8;
var n3;
var h10;
var k6;
var L3;
var B3;
var C6;
var I4;
var R5;
var q3;
var y9;
var D7;
var f22 = Dr(() => {
  v();
  g3();
  c2();
  t9 = (o12) => o12.account, A8 = u5(t9, (o12) => o12.address), n3 = u5(t9, A8, (o12, e4) => e4 in o12.accounts ? o12.accounts[e4] : g2), h10 = u5(t9, n3, (o12, e4) => {
    let r = o12, { accounts: m12 } = r, S8 = Et(r, ["accounts"]);
    return xt(yt({}, S8), { address: e4.address, account: e4 });
  }), k6 = u5(n3, (o12) => o12.balance), L3 = u5(n3, (o12) => {
    var e4;
    return ((e4 = o12 == null ? void 0 : o12.nonce) == null ? void 0 : e4.valueOf()) || 0;
  }), B3 = u5(t9, (o12) => o12.shard), C6 = u5(t9, (o12) => o12.ledgerAccount), I4 = u5(t9, (o12) => o12.walletConnectAccount), R5 = u5(t9, (o12) => o12.isAccountLoading), q3 = u5(t9, (o12) => o12.accountLoadingError), y9 = u5(t9, (o12) => o12.websocketEvent), D7 = u5(t9, (o12) => o12.websocketBatchEvent);
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-C6ERQ4DO.js
var import_dist94 = __toESM(require_dist());
var t10;
var x10;
var I5;
var m11;
var f23;
var u20;
var w4;
var C7;
var R6;
var h11;
var g14 = Dr(() => {
  v();
  f22();
  c2();
  t10 = (o12) => o12.loginInfo, x10 = u5(t10, (o12) => o12.loginMethod), I5 = u5(t10, A8, (o12, i11) => Boolean(i11)), m11 = u5(t10, (o12) => o12.walletConnectLogin), f23 = u5(t10, (o12) => o12.ledgerLogin), u20 = u5(t10, (o12) => o12.walletLogin), w4 = u5(t10, (o12) => o12.isLoginSessionInvalid), C7 = u5(t10, (o12) => o12.tokenLogin), R6 = u5(t10, (o12) => o12.logoutRoute), h11 = u5(t10, (o12) => o12.isWalletConnectV2Initialized);
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-ZHMC3BOL.js
var import_dist95 = __toESM(require_dist());
var a17;
var n4;
var p19;
var c9 = Dr(() => {
  v();
  c2();
  a17 = (t12) => t12.modals, n4 = u5(a17, (t12) => t12.txSubmittedModal), p19 = u5(a17, (t12) => t12.notificationModal);
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-BQNI2XMA.js
var import_dist96 = __toESM(require_dist());
var t11;
var I6;
var l18;
var f24;
var M5;
var S6 = Dr(() => {
  v();
  c2();
  t11 = (e4) => e4.signedMessageInfo, I6 = u5(t11, (e4) => e4.isSigning), l18 = u5(t11, (e4) => e4.errorMessage), f24 = u5(t11, (e4) => {
    let s6 = Object.keys(e4.signedSessions), o12 = s6.length;
    return e4.signedSessions[s6[o12 - 1]];
  }), M5 = u5(t11, (e4) => {
    let s6 = Object.keys(e4.signedSessions), o12 = s6.length;
    return s6.length > 0 ? s6[o12 - 1] : "";
  });
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-7TW5V77R.js
var import_dist97 = __toESM(require_dist());
var e3;
var p20;
var i10;
var c10 = Dr(() => {
  v();
  c2();
  e3 = (t12) => t12.toasts, p20 = u5(e3, (t12) => t12.customToasts), i10 = u5(e3, (t12) => t12.transactionToasts);
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-ZYJTJW6F.js
var import_dist98 = __toESM(require_dist());
var x11;
var s5 = Dr(() => {
  v();
  x11 = (e4, i11) => {
    let t12 = [], n5 = e4.indexOf(i11, 0);
    for (; n5 >= 0; )
      t12.push(n5), n5 = e4.indexOf(i11, n5 + 1);
    return t12;
  };
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-MFCDOAOP.js
var import_dist99 = __toESM(require_dist());
function F5(s6) {
  let o12 = [], i11 = 0;
  try {
    if ((s6 == null ? void 0 : s6.startsWith("MultiESDTNFTTransfer")) && (s6 == null ? void 0 : s6.includes("@"))) {
      let [, c11, p21, ...e4] = s6 == null ? void 0 : s6.split("@");
      if (c11) {
        let a19 = new bignumber_default(p21, 16).toNumber();
        if (a19 >= Number.MAX_SAFE_INTEGER)
          return [];
        let n5 = 0;
        for (let r = 0; r < a19; r++) {
          let t12 = { type: "nftTransaction", data: "", receiver: c11 };
          for (let l19 = 0; l19 < 3; l19++) {
            switch (l19) {
              case 0:
                t12.token = m2(e4[n5]), t12.data = e4[n5];
                break;
              case 1: {
                let u21 = e4[n5] && e4[n5].length ? e4[n5] : "";
                u21 && u21 !== "00" ? t12.nonce = u21 : t12.type = "esdtTransaction", t12.data = `${t12.data}@${e4[n5]}`;
                break;
              }
              case 2:
                t12.amount = new bignumber_default(e4[n5], 16).toString(10), t12.data = `${t12.data}@${e4[n5]}`;
                break;
              default:
                break;
            }
            i11 = n5 + 1, n5++;
          }
          o12[r] = t12;
        }
        let g16 = o12.length !== a19, h12 = o12.some((r) => x11(r.data, "@").length !== 2), x13 = o12.some((r) => r.data.startsWith("@"));
        if (g16 || h12 || x13)
          return [];
        if (e4[i11]) {
          let r = e4[i11];
          for (let t12 = i11 + 1; t12 < e4.length; t12++)
            r += "@" + e4[t12];
          o12[a19] = { type: "scCall", data: r, receiver: c11 };
        }
      }
    }
  } catch (c11) {
    return console.error("failed parsing tx", c11), o12;
  }
  return o12;
}
var N7 = Dr(() => {
  v();
  u2();
  f4();
  s5();
});

// node_modules/@multiversx/sdk-dapp/__chunks__/chunk-2CBBH2VA.js
var import_dist100 = __toESM(require_dist());
var k7 = Dr(() => {
  v();
  S7();
  l3();
});
var ar;
var w5 = Dr(() => {
  v();
  d16();
  ar = ({ transaction: r, filterBy: t12 }) => {
    if (!r.operations)
      return [];
    let n5 = u10(r);
    if (n5.length === 0)
      return [];
    if (!t12)
      return n5;
    let { action: m12, receiver: i11, sender: y10 } = t12;
    return n5.filter((u21) => !(m12 && u21.action !== m12 || y10 && u21.sender !== y10 || i11 && u21.receiver !== i11));
  };
});
var d16 = Dr(() => {
  v();
  y6();
  A9();
  p12();
  p10();
  y5();
  k7();
  l17();
  o3();
  o4();
  N7();
  d5();
  i3();
  v4();
  g();
  w5();
});
var x12;
var f25;
var br;
var kr;
var g15;
var wr;
var Ar;
var Er;
var Lr;
var Mr;
var hr;
var E4 = Dr(() => {
  v();
  I2();
  d16();
  c2();
  x12 = (r) => r.transactions, f25 = u5(x12, (r) => r.signedTransactions), br = u5(x12, (r) => r.signTransactionsError), kr = u5(x12, (r) => r.signTransactionsCancelMessage), g15 = (r) => (t12) => Object.entries(t12).reduce((n5, [m12, i11]) => (r(i11.status) && (n5[m12] = i11), n5), {}), wr = u5(f25, g15(j)), Ar = u5(f25, g15(k3)), Er = u5(f25, g15(q)), Lr = u5(f25, g15(y)), Mr = u5(x12, (r) => {
    var t12;
    return (r == null ? void 0 : r.transactionsToSign) == null ? null : xt(yt({}, r.transactionsToSign), { transactions: ((t12 = r == null ? void 0 : r.transactionsToSign) == null ? void 0 : t12.transactions.map((n5) => D2(n5))) || [] });
  }), hr = u5(f25, (r, t12) => t12, (r, t12) => t12 != null ? (r == null ? void 0 : r[t12]) || {} : {});
});
var S7 = Dr(() => {
  v();
  f22();
  a16();
  g14();
  c9();
  d3();
  S6();
  c10();
  u19();
  E4();
});
var A9 = Dr(() => {
  v();
  S7();
  l3();
});

export {
  m4 as m,
  y2 as y,
  u6 as u,
  N2 as N,
  w2 as w,
  R2 as R,
  i3 as i,
  d4 as d,
  o4 as o,
  U3 as U,
  d5 as d2,
  R3 as R2,
  C3 as C,
  a3 as a,
  W2 as W,
  u7 as u2,
  f6 as f,
  bignumber_default,
  d6 as d3,
  c4 as c,
  H2 as H,
  R4 as R3,
  d7 as d4,
  l5 as l,
  L,
  p6 as p,
  U4 as U2,
  g6 as g,
  o6 as o2,
  t4 as t,
  U5 as U3,
  j2 as j,
  h2 as h,
  a6 as a2,
  te,
  f12 as f2,
  g7 as g2,
  o7 as o3,
  v2 as v,
  T5 as T,
  U6 as U4,
  h5 as h2,
  i6 as i2,
  g9 as g3,
  f14 as f3,
  H3 as H2,
  N6 as N2,
  b2 as b,
  y5 as y2,
  q2 as q,
  B,
  x7 as x,
  y6 as y3,
  l14 as l2,
  u12 as u3,
  y7 as y4,
  p12 as p2,
  A6 as A,
  g12 as g4,
  d14 as d5,
  m9 as m2,
  m10 as m3,
  u16 as u4,
  B2,
  f20 as f4,
  x9 as x2,
  l17 as l3,
  d15 as d6,
  i9 as i3,
  S5 as S,
  A8 as A2,
  n3 as n,
  h10 as h3,
  L3 as L2,
  B3,
  C6 as C2,
  R5 as R4,
  y9 as y5,
  D7 as D,
  f22 as f5,
  t10 as t2,
  x10 as x3,
  I5 as I,
  m11 as m4,
  f23 as f6,
  u20 as u5,
  w4 as w2,
  C7 as C3,
  R6 as R5,
  g14 as g5,
  p19 as p3,
  t11 as t3,
  I6 as I2,
  l18 as l4,
  f24 as f7,
  M5 as M,
  p20 as p4,
  i10 as i4,
  c10 as c2,
  F5 as F,
  N7 as N3,
  d16 as d7,
  f25 as f8,
  br,
  kr,
  wr,
  Ar,
  Er,
  Lr,
  Mr,
  hr,
  S7 as S2
};
//# sourceMappingURL=chunk-3UOL3KDK.js.map
